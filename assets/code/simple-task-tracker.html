<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Kanban Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      // Replace G-XXXXXXXXXX with your Measurement ID if you have one
      // gtag('config', 'G-XXXXXXXXXX');
      gtag('config', 'G-DN4GBMQMRM'); // Using the provided ID for now
    </script>

    <style>
        /* Base styling */
        html, body { height: 100%; font-family: 'Nunito', sans-serif; scroll-behavior: smooth; }
        body { background-color: #f8fafc; /* slate-50 */ }

        /* Pomodoro Timer Panel */
        .pomodoro-panel { background-color: white; border-radius: 0.5rem; padding: 1rem 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); border: 1px solid #e5e7eb; display: flex; flex-direction: column; gap: 0.75rem; }
        .pomodoro-main-controls { display: flex; flex-direction: column; align-items: center; width: 100%; gap: 0.75rem;}
        @media (min-width: 768px) { .pomodoro-main-controls { flex-direction: row; justify-content: space-between; } }
        .pomodoro-display { font-size: 2.25rem; font-weight: 700; color: #1f2937; font-family: 'Menlo', 'Monaco', 'Consolas', "Courier New", monospace; line-height: 1; }
        .pomodoro-status { font-size: 0.875rem; font-weight: 600; padding: 0.25rem 0.75rem; border-radius: 9999px; text-transform: uppercase; letter-spacing: 0.05em; }
        .pomodoro-status.work { background-color: #fef3c7; color: #b45309; } /* amber-100, amber-700 */
        .pomodoro-status.break { background-color: #dcfce7; color: #166534; } /* green-100, green-700 */
        .pomodoro-controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.5rem; align-items: center;}
        .pomodoro-controls button { padding: 0.5rem 1rem; font-size: 0.875rem; }
        .pomodoro-controls button i { margin-right: 0.375rem; }
        .pomodoro-controls button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Pomodoro Settings Section */
        .pomodoro-settings { display: none; width: 100%; border-top: 1px solid #e5e7eb; margin-top: 1rem; padding-top: 1rem; gap: 0.75rem; flex-direction: column; align-items: center; }
        .pomodoro-settings.active { display: flex; }
        .pomodoro-settings-inputs { display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem; }
        .pomodoro-settings-inputs label { font-size: 0.875rem; color: #4b5563; display: flex; align-items: center; gap: 0.25rem;}
        .pomodoro-settings-inputs input[type="number"] { width: 4rem; padding: 0.25rem 0.5rem; border: 1px solid #d1d5db; border-radius: 0.25rem; font-size: 0.875rem; text-align: center; -moz-appearance: textfield; }
        .pomodoro-settings-inputs input[type="number"]::-webkit-outer-spin-button,
        .pomodoro-settings-inputs input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .pomodoro-settings button { font-size: 0.875rem; padding: 0.5rem 1rem;}

        /* Kanban Column Styling */
        .kanban-column { min-height: 350px; display: flex; flex-direction: column; transition: background-color 0.2s ease, box-shadow 0.3s ease; border-radius: 0.5rem; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); overflow: hidden; }
        .column-header { padding: 0.75rem 1rem; border-bottom-width: 1px; font-weight: 700; font-size: 1rem; display: flex; align-items: center; }
        .tasks-container { flex-grow: 1; padding: 0.75rem; overflow-y: auto; }
        .tasks-container > .kanban-task + .kanban-task { margin-top: 0.75rem; }

        /* NEW: Done Column Glow Effect */
        .kanban-column.done-glow {
            animation: pulse-glow 2.5s infinite ease-in-out;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0px 0px rgba(34, 197, 94, 0.3), 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); } /* green-500 */
            50% { box-shadow: 0 0 10px 4px rgba(34, 197, 94, 0.4), 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
        }

        /* Task Card Styling */
        .kanban-task { cursor: grab; transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-left-color 0.3s ease, opacity 0.3s ease; position: relative; padding: 0.625rem 2.25rem 0.625rem 1rem; border-radius: 0.375rem; background-color: white; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.07); display: flex; align-items: start; border-left: 3px solid #cbd5e1; }
        .kanban-task:hover { box-shadow: 0 4px 8px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06); border-left-color: #94a3b8; }
        .kanban-task:hover .task-actions { opacity: 1; }
        .kanban-task:active { cursor: grabbing; transform: scale(1.02); box-shadow: 0 8px 12px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .dragging { opacity: 0.7; transform: rotate(2deg); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .drag-over { background-color: rgba(100, 116, 139, 0.06); }

        /* Task Active State (Calmer Opacity Pulse) */
        .kanban-task.is-active { border-left-color: #fbbf24; animation: pulse-opacity 3s infinite ease-in-out; }
        @keyframes pulse-opacity { 0%, 100% { opacity: 1; } 50% { opacity: 0.9; } }

        /* Task Content (Text + Timer + Labels) */
        .task-content { display: flex; flex-direction: column; flex-grow: 1; margin-right: 0.25rem; word-break: break-word; }
        .task-text { line-height: 1.4; color: #374151; font-size: 0.9rem; margin-bottom: 0.25rem; }
        .task-labels { display: flex; flex-wrap: wrap; gap: 0.25rem; margin-bottom: 0.25rem; }
        .task-label { background-color: #e0e7ff; color: #3730a3; padding: 0.125rem 0.5rem; font-size: 0.65rem; border-radius: 9999px; font-weight: 600; }
        .task-timer-area { margin-top: auto; font-size: 0.7rem; color: #6b7280; font-family: 'Menlo', 'Monaco', 'Consolas', "Courier New", monospace; min-height: 1em; display: flex; flex-direction: column; gap: 0.125rem; }
        .task-timer { display: flex; align-items: center; }
        .task-timer i { margin-right: 0.25rem; color: #9ca3af; flex-shrink: 0; }

        /* Task Action Buttons */
        .task-actions { position: absolute; top: 0.375rem; right: 0.375rem; display: flex; flex-direction: column; gap: 0.25rem; opacity: 0.3; transition: opacity 0.2s ease-in-out; }
        .kanban-task:hover .task-actions { opacity: 1; }
        .task-action-btn { background-color: #f9fafb; border: 1px solid #e5e7eb; cursor: pointer; padding: 0.125rem; color: #6b7280; border-radius: 9999px; transition: all 0.15s ease-in-out; line-height: 1; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center; box-shadow: none; }
        .task-action-btn i { font-size: 0.65rem; }
        .task-action-btn:hover { background-color: #f3f4f6; color: #1f2937; border-color: #d1d5db; transform: scale(1.1); box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
        .task-action-btn.delete-btn:hover { background-color: #fee2e2; color: #ef4444; border-color: #fecaca; }
        .task-action-btn.edit-btn:hover { background-color: #dbeafe; color: #3b82f6; border-color: #bfdbfe; }
        .task-action-btn:active { transform: scale(0.95); filter: brightness(0.95); }

        /* Inline Editing */
        .editing-container { display: flex; flex-direction: column; gap: 0.5rem; width: 100%; }
        .editing-input { padding: 0.25rem 0.375rem; border: 1px solid #3b82f6; border-radius: 0.25rem; outline: none; font-size: 0.9rem; font-family: inherit; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); width: 100%; }
        .editing-input::placeholder { color: #9ca3af; font-size: 0.8rem;}

        /* Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 10000; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal-content { background-color: white; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); max-width: 400px; width: 90%; text-align: center; transform: scale(0.95); transition: transform 0.2s ease; }
        .modal-overlay.active .modal-content { transform: scale(1); }

        /* Custom Scrollbar */
        .tasks-container::-webkit-scrollbar { width: 6px; }
        .tasks-container::-webkit-scrollbar-track { background: transparent; }
        .tasks-container::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 10px; }
        .tasks-container::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

        /* Button Styling */
        .btn { display: inline-flex; align-items: center; justify-content: center; padding: 0.625rem 1.25rem; border-radius: 0.375rem; font-weight: 600; transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s, opacity 0.2s; border: 1px solid transparent; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); cursor: pointer; }
        .btn:active { transform: scale(0.98); }
        .btn-primary { background-color: #2563eb; color: white; border-color: #2563eb; }
        .btn-primary:hover:not(:disabled) { background-color: #1d4ed8; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .btn-danger { background-color: #dc2626; color: white; border-color: #dc2626; }
        .btn-danger:hover:not(:disabled) { background-color: #b91c1c; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .btn-secondary { background-color: #e5e7eb; color: #374151; border-color: #d1d5db; }
        .btn-secondary:hover:not(:disabled) { background-color: #d1d5db; border-color: #9ca3af; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .btn-clear { padding: 0.25rem 0.5rem; font-size: 0.75rem; color: #dc2626; background-color: transparent; border: none; box-shadow: none; font-weight: 500; border-radius: 0.25rem; transition: background-color 0.2s, color 0.2s; }
        .btn-clear:hover { background-color: #fee2e2; color: #b91c1c; }
        .btn i { margin-right: 0.5rem; }
        .btn-icon { padding: 0.5rem; width: 2.25rem; height: 2.25rem; border-radius: 9999px; }
        .btn-icon i { margin-right: 0; font-size: 0.875rem; }

    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <div class="pomodoro-panel">
             <div class="pomodoro-main-controls">
                 <div class="flex items-center gap-4">
                     <span id="pomodoro-display" class="pomodoro-display">25:00</span>
                     <span id="pomodoro-status" class="pomodoro-status work">Work</span>
                 </div>
                 <div class="pomodoro-controls">
                     <button id="pomodoro-start" class="btn btn-primary btn-sm"><i class="fas fa-play"></i>Start</button>
                     <button id="pomodoro-pause" class="btn btn-secondary btn-sm" style="display: none;"><i class="fas fa-pause"></i>Pause</button>
                     <button id="pomodoro-reset" class="btn btn-secondary btn-sm"><i class="fas fa-redo"></i>Reset</button>
                     <button id="pomodoro-settings-toggle" class="btn btn-secondary btn-icon btn-sm" title="Pomodoro Settings" aria-label="Pomodoro Settings">
                         <i class="fas fa-cog"></i>
                     </button>
                 </div>
             </div>
             <div id="pomodoro-settings" class="pomodoro-settings">
                 <div class="pomodoro-settings-inputs">
                     <label for="setting-work-mins">Work (min):
                         <input type="number" id="setting-work-mins" min="1" max="120" step="1">
                     </label>
                     <label for="setting-short-break-mins">Short Break (min):
                         <input type="number" id="setting-short-break-mins" min="1" max="30" step="1">
                     </label>
                     <label for="setting-long-break-mins">Long Break (min):
                         <input type="number" id="setting-long-break-mins" min="1" max="60" step="1">
                     </label>
                 </div>
                 <button id="pomodoro-save-settings" class="btn btn-primary btn-sm">Save Settings</button>
             </div>
         </div>

        <div class="mb-6 md:mb-8 bg-white p-4 rounded-lg shadow-sm border border-gray-200">
            <h2 class="text-lg font-semibold mb-3 text-gray-700">Add New Task</h2>
            <div class="flex flex-col sm:flex-row gap-3 mb-3">
                <input type="text" id="newTaskInput" placeholder="Enter task (try breaking large tasks down!)" class="flex-grow p-2.5 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition shadow-sm" aria-label="New task description">
                <input type="text" id="newTaskLabels" placeholder="Labels (comma-separated)..." class="p-2.5 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition shadow-sm sm:w-1/3" aria-label="New task labels">
            </div>
            <div class="flex flex-col sm:flex-row gap-3 items-center">
                 <button id="addTaskBtn" class="btn btn-primary flex-grow sm:flex-grow-0"> <i class="fas fa-plus fa-sm"></i>Add Task
                 </button>
                 <div class="data-actions flex gap-2 ml-auto">
                     <button id="exportDataBtn" class="btn btn-secondary btn-icon" title="Export Data (JSON)" aria-label="Export Data">
                         <i class="fas fa-download"></i>
                     </button>
                     <label for="importDataInput" class="btn btn-secondary btn-icon cursor-pointer" title="Import Data (JSON)" aria-label="Import Data">
                         <i class="fas fa-upload"></i>
                     </label>
                     <input type="file" id="importDataInput" accept=".json" style="display: none;">
                 </div>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 md:gap-6">
            <div id="todo" class="kanban-column bg-blue-50">
                <h2 class="column-header text-blue-800 border-blue-200"><i class="fas fa-list-ul mr-2 text-blue-500"></i>To Do</h2>
                <div class="tasks-container"></div>
            </div>
            <div id="inprogress" class="kanban-column bg-yellow-50">
                <h2 class="column-header text-yellow-800 border-yellow-200"><i id="inprogress-spinner" class="fas fa-spinner mr-2 text-yellow-600"></i>In Progress</h2>
                <div class="tasks-container"></div>
            </div>
            <div id="done" class="kanban-column bg-green-50">
                 <div class="column-header flex justify-between items-center text-green-800 border-green-200">
                     <span><i class="fas fa-check-circle mr-2 text-green-600"></i>Done</span>
                     <button id="clearDoneBtn" title="Clear all done tasks" class="btn-clear"><i class="fas fa-trash-alt mr-1"></i> Clear All</button>
                 </div>
                 <div class="tasks-container"></div>
            </div>
        </div>
    </div>

    <canvas id="confettiCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;"></canvas>

    <div id="confirmationModal" class="modal-overlay">
        <div class="modal-content">
            <p id="modalMessage" class="mb-5 text-gray-700 text-lg">Are you sure?</p>
            <div class="flex justify-center gap-4">
                <button id="confirmBtn" class="btn btn-danger">Confirm</button>
                <button id="cancelBtn" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element Selection ---
        const newTaskInput = document.getElementById('newTaskInput');
        const newTaskLabels = document.getElementById('newTaskLabels');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const columns = document.querySelectorAll('.kanban-column');
        const tasksContainers = document.querySelectorAll('.tasks-container');
        const todoTasksContainer = document.getElementById('todo').querySelector('.tasks-container');
        const inprogressTasksContainer = document.getElementById('inprogress').querySelector('.tasks-container');
        const doneTasksContainer = document.getElementById('done').querySelector('.tasks-container');
        const inprogressSpinner = document.getElementById('inprogress-spinner'); // Get spinner icon
        const doneColumn = document.getElementById('done'); // Get Done column element
        const clearDoneBtn = document.getElementById('clearDoneBtn');
        const confettiCanvas = document.getElementById('confettiCanvas');
        const confirmationModal = document.getElementById('confirmationModal');
        const modalMessage = document.getElementById('modalMessage');
        const confirmBtn = document.getElementById('confirmBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const pomodoroDisplay = document.getElementById('pomodoro-display');
        const pomodoroStatus = document.getElementById('pomodoro-status');
        const pomodoroStartBtn = document.getElementById('pomodoro-start');
        const pomodoroPauseBtn = document.getElementById('pomodoro-pause');
        const pomodoroResetBtn = document.getElementById('pomodoro-reset');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataInput = document.getElementById('importDataInput');
        const pomodoroSettingsToggleBtn = document.getElementById('pomodoro-settings-toggle');
        const pomodoroSettingsDiv = document.getElementById('pomodoro-settings');
        const settingWorkMinsInput = document.getElementById('setting-work-mins');
        const settingShortBreakMinsInput = document.getElementById('setting-short-break-mins');
        const settingLongBreakMinsInput = document.getElementById('setting-long-break-mins');
        const pomodoroSaveSettingsBtn = document.getElementById('pomodoro-save-settings');

        // --- Global Variables & Instances ---
        const myConfetti = confetti.create(confettiCanvas, { resize: true, useWorker: true });
        const activeTaskTimers = {};
        let draggedItem = null;
        let sourceColumnId = null;
        let confirmCallback = null;

        // --- Default Pomodoro Durations ---
        const DEFAULT_WORK_MINS = 25;
        const DEFAULT_SHORT_BREAK_MINS = 5;
        const DEFAULT_LONG_BREAK_MINS = 15;

        // --- Pomodoro Settings ---
        let currentWorkMins = DEFAULT_WORK_MINS;
        let currentShortBreakMins = DEFAULT_SHORT_BREAK_MINS;
        let currentLongBreakMins = DEFAULT_LONG_BREAK_MINS;

        // Pomodoro Timer State
        const POMODORO_STATES = { WORK: 'Work', SHORT_BREAK: 'Break', LONG_BREAK: 'Break' };
        let pomodoroIntervalId = null; let pomodoroState = POMODORO_STATES.WORK;
        let pomodoroTimeLeft = currentWorkMins * 60;
        let pomodoroCycles = 0;

        // --- Sound Synthesis (Tone.js) ---
        let soundsReady = false;
        let taskCompleteSynth = null;
        let pomodoroEndSynth = null;

        const initAudio = () => { /* ... (no changes) ... */
            if (soundsReady) return;
            Tone.start().then(() => {
                taskCompleteSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 } }).toDestination();
                 pomodoroEndSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.2, release: 0.8 } }).toDestination();
                 console.log("Audio ready."); soundsReady = true;
            }).catch(e => console.error("Tone.start failed:", e));
        };
        const playTaskCompleteSound = () => { /* ... (no changes) ... */
            if (!soundsReady || !taskCompleteSynth) return;
            try { taskCompleteSynth.triggerAttackRelease("C5", "8n", Tone.now()); taskCompleteSynth.triggerAttackRelease("G5", "8n", Tone.now() + 0.15); }
            catch (e) { console.error("Error playing task complete sound:", e); }
        };
        const playPomodoroEndSound = () => { /* ... (no changes) ... */
             if (!soundsReady || !pomodoroEndSynth) return;
             try { pomodoroEndSynth.triggerAttackRelease("E4", "4n", Tone.now()); pomodoroEndSynth.triggerAttackRelease("G4", "4n", Tone.now() + 0.3); }
             catch (e) { console.error("Error playing pomodoro end sound:", e); }
        };


        // --- Helper Functions ---

        /** Formats seconds into MM:SS string. */
        const formatPomodoroTime = (totalSeconds) => { /* ... (no changes) ... */
            const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        };
        /** Updates the Pomodoro timer display in the UI. */
        const updatePomodoroDisplay = () => { /* ... (no changes) ... */
            pomodoroDisplay.textContent = formatPomodoroTime(pomodoroTimeLeft);
            document.title = `${formatPomodoroTime(pomodoroTimeLeft)} - ${pomodoroState} | Kanban`;
        };
        /** Updates the Pomodoro status indicator (Work/Break). */
        const updatePomodoroStatus = () => { /* ... (no changes) ... */
            pomodoroStatus.textContent = pomodoroState;
            pomodoroStatus.className = `pomodoro-status ${pomodoroState === POMODORO_STATES.WORK ? 'work' : 'break'}`;
        };
        /** Enables/disables Pomodoro control buttons based on timer state. */
        const setPomodoroControlsState = (isRunning) => { /* ... (no changes) ... */
            pomodoroStartBtn.disabled = isRunning;
            pomodoroPauseBtn.disabled = !isRunning;
            pomodoroResetBtn.disabled = isRunning;
            pomodoroSettingsToggleBtn.disabled = isRunning;
        };

        /** Resets the Pomodoro timer based on the *currently set* pomodoroState. */
        const resetPomodoroTimerTime = (forceUpdateDisplay = true) => { /* ... (no changes) ... */
            clearInterval(pomodoroIntervalId); pomodoroIntervalId = null;
            switch (pomodoroState) {
                case POMODORO_STATES.WORK: pomodoroTimeLeft = currentWorkMins * 60; break;
                case POMODORO_STATES.SHORT_BREAK: pomodoroTimeLeft = currentShortBreakMins * 60; break;
                case POMODORO_STATES.LONG_BREAK: pomodoroTimeLeft = currentLongBreakMins * 60; break;
            }
            if (forceUpdateDisplay) {
                updatePomodoroDisplay(); updatePomodoroStatus();
                pomodoroStartBtn.style.display = 'inline-flex'; pomodoroPauseBtn.style.display = 'none';
                setPomodoroControlsState(false); document.title = "Focus Kanban Tracker";
            }
        };

        /** Handles the reset button click - always goes back to WORK state. */
        const handlePomodoroReset = () => { /* ... (no changes) ... */
            pomodoroState = POMODORO_STATES.WORK;
            resetPomodoroTimerTime();
        };

        /** Switches to the next Pomodoro state. */
        const nextPomodoroState = () => { /* ... (no changes) ... */
            playPomodoroEndSound();
            if (pomodoroState === POMODORO_STATES.WORK) {
                pomodoroCycles++; pomodoroState = (pomodoroCycles % 4 === 0) ? POMODORO_STATES.LONG_BREAK : POMODORO_STATES.SHORT_BREAK;
            } else { pomodoroState = POMODORO_STATES.WORK; }
            resetPomodoroTimerTime();
        };
        /** Starts the Pomodoro countdown. */
        const startPomodoro = () => { /* ... (no changes) ... */
            initAudio();
            if (pomodoroIntervalId) return;
            pomodoroStartBtn.style.display = 'none'; pomodoroPauseBtn.style.display = 'inline-flex';
            setPomodoroControlsState(true);
            pomodoroIntervalId = setInterval(() => {
                pomodoroTimeLeft--; updatePomodoroDisplay();
                if (pomodoroTimeLeft <= 0) {
                    clearInterval(pomodoroIntervalId); pomodoroIntervalId = null; nextPomodoroState();
                }
            }, 1000);
        };
        /** Pauses the Pomodoro countdown. */
        const pausePomodoro = () => { /* ... (no changes) ... */
            clearInterval(pomodoroIntervalId); pomodoroIntervalId = null;
            pomodoroStartBtn.style.display = 'inline-flex'; pomodoroPauseBtn.style.display = 'none';
            setPomodoroControlsState(false);
        };

        /** Formats task timer milliseconds into a D:H:M:S string. */
        const formatTaskTime = (ms) => { /* ... (no changes) ... */
            if (ms === null || ms === undefined || ms < 0) return '';
            let s = Math.floor(ms / 1000); let m = Math.floor(s / 60); let h = Math.floor(m / 60); let d = Math.floor(h / 24);
            s %= 60; m %= 60; h %= 24; let p = [];
            if (d > 0) p.push(`${d}D`); if (h > 0 || d > 0) p.push(`${h}H`); if (m > 0 || h > 0 || d > 0) p.push(`${m}m`); p.push(`${s}s`);
            return p.join(':');
        };

        // --- Task Work Timer Functions ---
        const updateTaskTimerDisplay = (taskElement, startTime) => { /* ... (no changes) ... */
            const timerDiv = taskElement.querySelector('.task-timer');
            if (!timerDiv || !startTime) return;
            const elapsed = Date.now() - startTime;
            timerDiv.innerHTML = `<i class="fas fa-stopwatch fa-xs"></i> ${formatTaskTime(elapsed)}`;
            timerDiv.style.display = 'flex';
        };
        const startTaskTimerInterval = (taskElement, startTime) => { /* ... (no changes) ... */
            const taskId = taskElement.id; stopTaskTimerInterval(taskElement);
            updateTaskTimerDisplay(taskElement, startTime);
            activeTaskTimers[taskId] = setInterval(() => updateTaskTimerDisplay(taskElement, startTime), 1000);
            taskElement.dataset.timerStartTime = startTime;
            taskElement.classList.add('is-active');
        };
        const stopTaskTimerInterval = (taskElement) => { /* ... (no changes) ... */
            const taskId = taskElement.id;
            if (activeTaskTimers[taskId]) { clearInterval(activeTaskTimers[taskId]); delete activeTaskTimers[taskId]; }
            taskElement.classList.remove('is-active');
        };
        const displayTotalTaskTime = (taskElement, totalTimeMs) => { /* ... (no changes) ... */
            const timerDiv = taskElement.querySelector('.task-timer');
            if (timerDiv) {
                if (totalTimeMs !== null && totalTimeMs >= 0) {
                    timerDiv.innerHTML = `<i class="fas fa-check-circle fa-xs text-green-600"></i> Total: ${formatTaskTime(totalTimeMs)}`;
                    timerDiv.style.display = 'flex';
                } else {
                    timerDiv.innerHTML = ''; timerDiv.style.display = 'none';
                }
            }
        };
        const pauseWorkTimer = (taskElement) => { /* ... (no changes) ... */
            const startTime = taskElement.dataset.timerStartTime ? parseInt(taskElement.dataset.timerStartTime, 10) : null;
            if (startTime) {
                const elapsed = Date.now() - startTime;
                let currentTotalTime = parseInt(taskElement.dataset.totalTime || '0', 10);
                taskElement.dataset.totalTime = currentTotalTime + elapsed;
                delete taskElement.dataset.timerStartTime;
            }
            stopTaskTimerInterval(taskElement);
            const timerDiv = taskElement.querySelector('.task-timer');
            if(timerDiv) timerDiv.style.display = 'none'; // Hide timer when paused
        };

        // --- Task Element Creation & Management ---
        const createTaskElement = (taskData) => { /* ... (no changes, except removing redundant timer display logic here) ... */
            const { id, text, labels = [], startTime = null, totalTime = 0 } = taskData;
            const task = document.createElement('div');
            task.className = 'kanban-task'; task.draggable = true;
            task.id = id || `task-${Date.now()}`;
            task.dataset.totalTime = totalTime || 0;
            task.dataset.labels = JSON.stringify(labels);
            // No need to set startTime dataset here, it's handled when loading/moving

            const contentDiv = document.createElement('div'); contentDiv.className = 'task-content';
            const textSpan = document.createElement('span'); textSpan.className = 'task-text'; textSpan.textContent = text;
            contentDiv.appendChild(textSpan);
            const labelsDiv = document.createElement('div'); labelsDiv.className = 'task-labels';
            labels.forEach(label => {
                const labelSpan = document.createElement('span');
                labelSpan.className = 'task-label';
                labelSpan.textContent = label;
                labelsDiv.appendChild(labelSpan);
            });
            contentDiv.appendChild(labelsDiv);
            const timerAreaDiv = document.createElement('div'); timerAreaDiv.className = 'task-timer-area';
            const timerDiv = document.createElement('div'); timerDiv.className = 'task-timer'; timerDiv.style.display = 'none'; // Start hidden
            timerAreaDiv.appendChild(timerDiv);
            contentDiv.appendChild(timerAreaDiv);
            task.appendChild(contentDiv);

            const actionsDiv = document.createElement('div'); actionsDiv.className = 'task-actions';
            const editBtn = document.createElement('button'); editBtn.className = 'task-action-btn edit-btn'; editBtn.innerHTML = '<i class="fas fa-pencil-alt fa-xs"></i>'; editBtn.title = "Edit task"; editBtn.setAttribute('aria-label', 'Edit task');
            editBtn.addEventListener('click', (e) => { e.stopPropagation(); enableEditing(task, contentDiv); });
            actionsDiv.appendChild(editBtn);
            const deleteBtn = document.createElement('button'); deleteBtn.className = 'task-action-btn delete-btn'; deleteBtn.innerHTML = '<i class="fas fa-trash-alt fa-xs"></i>'; deleteBtn.title = "Delete task"; deleteBtn.setAttribute('aria-label', 'Delete task');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation(); const currentText = task.querySelector('.task-text').textContent;
                showConfirmationModal(`Delete task: "${currentText}"?`, () => {
                    stopTaskTimerInterval(task); // Ensure timer stops if deleted from In Progress
                    task.remove();
                    updateBoardState(); // Update spinner/glow
                    saveTasks(); // Save after removal
                });
            });
            actionsDiv.appendChild(deleteBtn);
            task.appendChild(actionsDiv);

            task.addEventListener('dragstart', handleDragStart); task.addEventListener('dragend', handleDragEnd);
            return task;
        };
        /** Enables inline editing for a task's text and labels. */
        const enableEditing = (taskElement, contentDiv) => { /* ... (no changes) ... */
            const textSpan = contentDiv.querySelector('.task-text');
            const labelsDiv = contentDiv.querySelector('.task-labels');
            const timerArea = contentDiv.querySelector('.task-timer-area');
            const currentText = textSpan.textContent;
            const currentLabels = JSON.parse(taskElement.dataset.labels || '[]');
            const editContainer = document.createElement('div');
            editContainer.className = 'editing-container';
            const textInput = document.createElement('input');
            textInput.type = 'text'; textInput.value = currentText;
            textInput.className = 'editing-input';
            textInput.setAttribute('aria-label', 'Edit task description');
            editContainer.appendChild(textInput);
            const labelsInput = document.createElement('input');
            labelsInput.type = 'text'; labelsInput.value = currentLabels.join(', ');
            labelsInput.placeholder = 'Labels (comma-separated)...';
            labelsInput.className = 'editing-input';
            labelsInput.setAttribute('aria-label', 'Edit task labels');
            editContainer.appendChild(labelsInput);
            textSpan.style.display = 'none'; labelsDiv.style.display = 'none'; if(timerArea) timerArea.style.display = 'none';
            contentDiv.insertBefore(editContainer, textSpan); textInput.select();
            const saveEdit = () => {
                const newText = textInput.value.trim();
                const newLabels = labelsInput.value.split(',').map(label => label.trim()).filter(label => label !== '');
                textSpan.textContent = (newText && newText !== currentText) ? newText : currentText;
                taskElement.dataset.labels = JSON.stringify(newLabels);
                labelsDiv.innerHTML = ''; newLabels.forEach(label => { const labelSpan = document.createElement('span'); labelSpan.className = 'task-label'; labelSpan.textContent = label; labelsDiv.appendChild(labelSpan); });
                contentDiv.removeChild(editContainer); textSpan.style.display = ''; labelsDiv.style.display = 'flex'; if(timerArea) timerArea.style.display = 'flex';
                if ((newText && newText !== currentText) || (JSON.stringify(newLabels) !== JSON.stringify(currentLabels))) {
                     saveTasks(); // Save only if changed
                     // No need to call updateBoardState here, saveTasks does it
                }
            };
            let saved = false; const handleSave = () => { if (!saved) { saved = true; saveEdit(); } };
            const handleCancel = () => { if (!saved) { saved = true; contentDiv.removeChild(editContainer); textSpan.style.display = ''; labelsDiv.style.display = 'flex'; if(timerArea) timerArea.style.display = 'flex'; } };
            textInput.addEventListener('blur', handleSave); labelsInput.addEventListener('blur', handleSave);
            editContainer.addEventListener('keypress', (e) => { if (e.key === 'Enter') { handleSave(); } else if (e.key === 'Escape') { handleCancel(); } });
            editContainer.addEventListener('keydown', (e) => { if (e.key === 'Escape') { handleCancel(); } });
        };
        /** Adds a new task to the 'To Do' column. */
        const addTask = () => { /* ... (no changes) ... */
            initAudio();
            const taskText = newTaskInput.value.trim(); const labelText = newTaskLabels.value.trim();
            if (taskText === '') { newTaskInput.focus(); return; }
            const labels = labelText.split(',').map(label => label.trim()).filter(label => label !== '');
            const taskData = { id: `task-${Date.now()}`, text: taskText, labels: labels };
            const newTask = createTaskElement(taskData);
            todoTasksContainer.appendChild(newTask); // Use specific container
            newTaskInput.value = ''; newTaskLabels.value = '';
            saveTasks(); // This will also trigger updateBoardState
        };

        // --- Drag and Drop Event Handlers ---
        function handleDragStart(e) { /* ... (no changes) ... */
            initAudio();
            if (e.target.querySelector('input:focus') || e.target.querySelector('.editing-input')) { e.preventDefault(); return; }
            draggedItem = e.target; sourceColumnId = draggedItem.closest('.kanban-column').id;
            setTimeout(() => { if(draggedItem) draggedItem.classList.add('dragging'); }, 0); // Check if draggedItem still exists
            e.dataTransfer.effectAllowed = 'move';
            try { e.dataTransfer.setData('text/plain', e.target.id); } catch (error) { console.error("Error setting drag data:", error); }
        }
        function handleDragEnd(e) { /* ... (no changes) ... */
            setTimeout(() => {
                if (draggedItem) { draggedItem.classList.remove('dragging'); }
                draggedItem = null; sourceColumnId = null; columns.forEach(col => col.classList.remove('drag-over'));
            }, 0);
        }
        function handleDragOver(e) { /* ... (no changes) ... */
            e.preventDefault(); e.dataTransfer.dropEffect = 'move';
            const targetColumn = e.currentTarget.closest('.kanban-column');
            columns.forEach(col => { col.classList.toggle('drag-over', col === targetColumn); });
        }
        function handleDragEnter(e) { /* ... (no changes) ... */
             e.preventDefault(); e.currentTarget.closest('.kanban-column').classList.add('drag-over');
        }
        function handleDragLeave(e) { /* ... (no changes) ... */
            const column = e.currentTarget.closest('.kanban-column');
            // Check if the relatedTarget (where the mouse is going) is outside the current column
            if (!column || !column.contains(e.relatedTarget)) {
                 if(column) column.classList.remove('drag-over');
            }
        }
        function handleDrop(e) {
            e.preventDefault();
            const dropZoneContainer = e.currentTarget;
            const dropZoneColumn = dropZoneContainer.closest('.kanban-column');
            if (!draggedItem || !dropZoneContainer.classList.contains('tasks-container') || !dropZoneColumn) {
                if (draggedItem) draggedItem.classList.remove('dragging');
                draggedItem = null; sourceColumnId = null;
                columns.forEach(col => col.classList.remove('drag-over'));
                return;
            }

            const destinationColumnId = dropZoneColumn.id;
            const wasInProgress = sourceColumnId === 'inprogress';
            const willBeInProgress = destinationColumnId === 'inprogress';
            const willBeInDone = destinationColumnId === 'done';
            const willBeInTodo = destinationColumnId === 'todo';

            // --- Timer Logic ---
            if (wasInProgress && !willBeInProgress) {
                // Moving OUT of In Progress: Pause timer, store elapsed time
                pauseWorkTimer(draggedItem);
            }
            if (!wasInProgress && willBeInProgress) {
                // Moving INTO In Progress: Start timer (or restart if paused)
                const newWorkStartTime = Date.now();
                startTaskTimerInterval(draggedItem, newWorkStartTime);
                // Clear any "Total:" display if moving back from Done
                const timerDiv = draggedItem.querySelector('.task-timer');
                if (timerDiv && timerDiv.innerHTML.includes('Total:')) {
                    timerDiv.innerHTML = ''; // Clear it, display will update with stopwatch
                    timerDiv.style.display = 'flex'; // Ensure it's visible
                }
            }

            // --- Display Logic ---
            if (willBeInDone) {
                // Moving INTO Done: Display total time, play sound, confetti
                const totalTime = parseInt(draggedItem.dataset.totalTime || '0', 10);
                displayTotalTaskTime(draggedItem, totalTime);
                playTaskCompleteSound();
                triggerConfetti();
            } else if (willBeInTodo) {
                // Moving INTO To Do: Clear timer display and active state
                const timerDiv = draggedItem.querySelector('.task-timer');
                if (timerDiv) {
                    timerDiv.innerHTML = '';
                    timerDiv.style.display = 'none';
                }
                draggedItem.classList.remove('is-active');
                // Reset total time if moving back to To Do? Optional, depends on desired logic.
                // draggedItem.dataset.totalTime = '0';
            } else if (willBeInProgress && !wasInProgress) {
                 // Moving INTO In Progress (from ToDo/Done): Timer started above, ensure display is correct
                 const startTime = parseInt(draggedItem.dataset.timerStartTime, 10);
                 updateTaskTimerDisplay(draggedItem, startTime); // Initial display update
            }


            // --- DOM Manipulation ---
            const afterElement = getDragAfterElement(dropZoneContainer, e.clientY);
            if (afterElement == null) {
                dropZoneContainer.appendChild(draggedItem);
            } else {
                dropZoneContainer.insertBefore(draggedItem, afterElement);
            }

            dropZoneColumn.classList.remove('drag-over');
            saveTasks(); // Save state and update spinner/glow
        }
        /** Finds element to insert before based on Y-coordinate. */
        function getDragAfterElement(container, y) { /* ... (no changes) ... */
            const draggableElements = [...container.querySelectorAll('.kanban-task:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; } else { return closest; }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- Other Event Handlers ---
        const triggerConfetti = () => { /* ... (no changes) ... */ myConfetti({ particleCount: 120, spread: 75, origin: { y: 0.6 }, zIndex: 10000, gravity: 0.8 }); };
        const handleClearDone = () => {
             if (doneTasksContainer.children.length > 0) {
                 showConfirmationModal("Clear all tasks from the 'Done' column?", () => {
                     doneTasksContainer.innerHTML = '';
                     saveTasks(); // Save and update board state
                 });
             }
        };

        // --- Confirmation Modal ---
        function showConfirmationModal(message, callback) { /* ... (no changes) ... */ modalMessage.textContent = message; confirmCallback = callback; confirmationModal.classList.add('active'); }
        function hideConfirmationModal() { /* ... (no changes) ... */ confirmationModal.classList.remove('active'); confirmCallback = null; }

        // --- Data Export/Import ---
        const exportData = () => { /* ... (no changes) ... */
            const tasksData = {};
            columns.forEach(column => {
                const columnId = column.id; tasksData[columnId] = [];
                column.querySelectorAll('.kanban-task').forEach(task => {
                    const textSpan = task.querySelector('.task-text');
                    if (textSpan) {
                        tasksData[columnId].push({
                            id: task.id, text: textSpan.textContent, labels: JSON.parse(task.dataset.labels || '[]'),
                            startTime: task.dataset.timerStartTime ? parseInt(task.dataset.timerStartTime, 10) : null,
                            totalTime: parseInt(task.dataset.totalTime || '0', 10)
                        });
                    }
                });
            });
            try {
                const jsonString = JSON.stringify(tasksData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, ''); a.download = `kanban_data_${timestamp}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            } catch (error) { console.error("Error exporting data:", error); alert("Failed to export data. See console for details."); }
        };
        const handleImportData = (event) => { /* ... (no changes) ... */
            const file = event.target.files[0]; if (!file) { return; }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (typeof importedData !== 'object' || importedData === null) { throw new Error("Invalid data format: Not an object."); }
                    const columnIds = Object.keys(importedData); const expectedCols = ['todo', 'inprogress', 'done'];
                    if (!expectedCols.every(col => columnIds.includes(col) && Array.isArray(importedData[col]))) { throw new Error("Invalid data format: Missing or invalid columns."); }
                    showConfirmationModal("Importing data will overwrite the current board. Are you sure?", () => {
                        tasksContainers.forEach(container => container.innerHTML = '');
                        Object.values(activeTaskTimers).forEach(clearInterval); for (const key in activeTaskTimers) { delete activeTaskTimers[key]; }
                        loadTasksFromData(importedData);
                        saveTasks(); // Save the newly loaded data and update UI state
                        alert("Data imported successfully!");
                    });
                } catch (error) { console.error("Error importing data:", error); alert(`Failed to import data: ${error.message}`); }
                finally { event.target.value = null; }
            };
            reader.onerror = (e) => { console.error("Error reading file:", e); alert("Failed to read the selected file."); event.target.value = null; };
            reader.readAsText(file);
        };

        // --- Local Storage Persistence ---
        const POMODORO_SETTINGS_KEY = 'pomodoroSettings'; // Key for settings

        // --- NEW: Functions to Update Board Visual State ---

        /** Updates the In Progress spinner animation based on tasks present. */
        const updateSpinnerAnimation = () => {
            if (inprogressSpinner) {
                const hasTasks = inprogressTasksContainer.children.length > 0;
                inprogressSpinner.classList.toggle('fa-spin', hasTasks);
            }
        };

        /** Updates the Done column glow effect based on task distribution. */
        const updateDoneGlow = () => {
            if (doneColumn) {
                const todoEmpty = todoTasksContainer.children.length === 0;
                const inprogressEmpty = inprogressTasksContainer.children.length === 0;
                const doneHasTasks = doneTasksContainer.children.length > 0;

                // Glow only if ToDo and InProgress are empty, and Done has tasks
                doneColumn.classList.toggle('done-glow', todoEmpty && inprogressEmpty && doneHasTasks);
            }
        };

        /** Central function to update dynamic visual states */
        const updateBoardState = () => {
            updateSpinnerAnimation();
            updateDoneGlow();
        }

        // --- Modified Save/Load Functions ---

        const saveTasks = () => {
            const tasksData = {};
            columns.forEach(column => {
                const columnId = column.id; tasksData[columnId] = [];
                column.querySelectorAll('.kanban-task').forEach(task => {
                    const textSpan = task.querySelector('.task-text');
                    if (textSpan) {
                        tasksData[columnId].push({
                            id: task.id, text: textSpan.textContent, labels: JSON.parse(task.dataset.labels || '[]'),
                            startTime: task.dataset.timerStartTime ? parseInt(task.dataset.timerStartTime, 10) : null,
                            totalTime: parseInt(task.dataset.totalTime || '0', 10)
                        });
                    }
                });
            });
            try { localStorage.setItem('kanbanTasks', JSON.stringify(tasksData)); }
            catch (error) { console.error("Error saving tasks to localStorage:", error); }

            // Update visual state AFTER saving
            updateBoardState();
        };

        /** Loads tasks from a data object (used by initial load and import). */
        const loadTasksFromData = (tasksData) => {
             Object.keys(tasksData).forEach(columnId => {
                 const columnElement = document.getElementById(columnId);
                 if (columnElement) {
                     const tasksContainer = columnElement.querySelector('.tasks-container');
                     tasksData[columnId].forEach(taskData => {
                         if(taskData && taskData.id && typeof taskData.text === 'string') {
                             taskData.labels = Array.isArray(taskData.labels) ? taskData.labels : [];
                             const taskElement = createTaskElement(taskData); tasksContainer.appendChild(taskElement);

                             // Restore state based on column
                             if (columnId === 'inprogress') {
                                 if (taskData.startTime) {
                                     // Calculate elapsed time since page was closed
                                     const elapsedSinceLoad = Date.now() - taskData.startTime;
                                     const previousTotal = taskData.totalTime || 0;
                                     // Decide how to handle time passed while closed.
                                     // Option 1: Resume timer, adding elapsed time to total when paused/moved.
                                     startTaskTimerInterval(taskElement, taskData.startTime);
                                     // Option 2: Add elapsed time immediately (timer shows total time since original start)
                                     // taskElement.dataset.totalTime = previousTotal + elapsedSinceLoad;
                                     // startTaskTimerInterval(taskElement, taskData.startTime); // Still need interval
                                     // Option 3: Just restore totalTime and don't restart timer automatically
                                     // displayTotalTaskTime(taskElement, previousTotal);
                                     // delete taskElement.dataset.timerStartTime; // Remove start time if not auto-restarting
                                 } else {
                                     // Task was in progress but timer wasn't running (maybe paused before close?)
                                     displayTotalTaskTime(taskElement, taskData.totalTime || 0); // Show paused time
                                 }
                             } else if (columnId === 'done') {
                                 displayTotalTaskTime(taskElement, taskData.totalTime || 0);
                             } else { // To Do
                                 const timerDiv = taskElement.querySelector('.task-timer');
                                 if(timerDiv) timerDiv.style.display = 'none';
                             }
                         } else { console.warn("Skipping invalid task data during load/import:", taskData); }
                     });
                 }
             });
             // Update visual state after loading all tasks
             updateBoardState();
        };

        /** Loads tasks from localStorage on initial page load. */
        const loadTasks = () => {
             Object.values(activeTaskTimers).forEach(clearInterval); for (const key in activeTaskTimers) { delete activeTaskTimers[key]; }
             let savedTasksJson; try { savedTasksJson = localStorage.getItem('kanbanTasks'); } catch (error) { console.error("Error reading tasks from localStorage:", error); return; }
             if (savedTasksJson) {
                 try { const tasksData = JSON.parse(savedTasksJson); loadTasksFromData(tasksData); }
                 catch (error) { console.error("Error parsing saved tasks JSON:", error); localStorage.removeItem('kanbanTasks'); /* Clear corrupted data */ }
             }
             // Ensure board state is correct even if no tasks were loaded
             updateBoardState();
        };

        /** Loads Pomodoro settings from localStorage. */
        const loadPomodoroSettings = () => { /* ... (no changes) ... */
            try {
                const savedSettings = localStorage.getItem(POMODORO_SETTINGS_KEY);
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    currentWorkMins = parseInt(settings.work, 10) || DEFAULT_WORK_MINS;
                    currentShortBreakMins = parseInt(settings.shortBreak, 10) || DEFAULT_SHORT_BREAK_MINS;
                    currentLongBreakMins = parseInt(settings.longBreak, 10) || DEFAULT_LONG_BREAK_MINS;
                } else {
                    currentWorkMins = DEFAULT_WORK_MINS; currentShortBreakMins = DEFAULT_SHORT_BREAK_MINS; currentLongBreakMins = DEFAULT_LONG_BREAK_MINS;
                }
            } catch (error) {
                console.error("Error loading Pomodoro settings:", error);
                currentWorkMins = DEFAULT_WORK_MINS; currentShortBreakMins = DEFAULT_SHORT_BREAK_MINS; currentLongBreakMins = DEFAULT_LONG_BREAK_MINS;
            }
            // Reset timer display based on loaded settings, but don't force state yet
            resetPomodoroTimerTime(false);
        };

        /** Saves Pomodoro settings to localStorage. */
        const savePomodoroSettings = (settings) => { /* ... (no changes) ... */
             try { localStorage.setItem(POMODORO_SETTINGS_KEY, JSON.stringify(settings)); }
             catch (error) { console.error("Error saving Pomodoro settings:", error); alert("Could not save Pomodoro settings."); }
        };

        /** Handles saving the new Pomodoro settings from the input fields. */
        const handleSavePomodoroSettings = () => { /* ... (no changes) ... */
             const newWorkMins = parseInt(settingWorkMinsInput.value, 10);
             const newShortBreakMins = parseInt(settingShortBreakMinsInput.value, 10);
             const newLongBreakMins = parseInt(settingLongBreakMinsInput.value, 10);
             if (isNaN(newWorkMins) || newWorkMins < 1 || isNaN(newShortBreakMins) || newShortBreakMins < 1 || isNaN(newLongBreakMins) || newLongBreakMins < 1) {
                 alert("Please enter valid positive numbers for all durations."); return;
             }
             currentWorkMins = newWorkMins; currentShortBreakMins = newShortBreakMins; currentLongBreakMins = newLongBreakMins;
             savePomodoroSettings({ work: currentWorkMins, shortBreak: currentShortBreakMins, longBreak: currentLongBreakMins });
             handlePomodoroReset(); // Use the reset handler which forces WORK state and updates display
             pomodoroSettingsDiv.classList.remove('active');
             alert("Pomodoro settings saved!");
        };


        // --- Event Listener Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            loadPomodoroSettings(); // Load settings first
            loadTasks();           // Load tasks and update board state
            handlePomodoroReset(); // Set initial Pomodoro state to WORK & update display

            // Init audio on first interaction
            document.body.addEventListener('click', initAudio, { once: true });
            document.body.addEventListener('keypress', initAudio, { once: true });
            document.body.addEventListener('dragstart', initAudio, { once: true });

            // Keyboard shortcut for new task
            document.addEventListener('keydown', (e) => { if (e.altKey && e.key.toLowerCase() === 'n') { e.preventDefault(); newTaskInput.focus(); } });
        });
        addTaskBtn.addEventListener('click', addTask);
        newTaskInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTask(); });
        newTaskLabels.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTask(); });
        clearDoneBtn.addEventListener('click', handleClearDone);
        tasksContainers.forEach(container => {
            container.addEventListener('dragover', handleDragOver); container.addEventListener('dragenter', handleDragEnter);
            container.addEventListener('dragleave', handleDragLeave); container.addEventListener('drop', handleDrop);
        });
        confirmBtn.addEventListener('click', () => { if (typeof confirmCallback === 'function') { try { confirmCallback(); } catch (error) { console.error("Error executing confirmation callback:", error); } } hideConfirmationModal(); });
        cancelBtn.addEventListener('click', hideConfirmationModal);
        confirmationModal.addEventListener('click', (e) => { if (e.target === confirmationModal) hideConfirmationModal(); });
        pomodoroStartBtn.addEventListener('click', startPomodoro);
        pomodoroPauseBtn.addEventListener('click', pausePomodoro);
        pomodoroResetBtn.addEventListener('click', handlePomodoroReset);
        exportDataBtn.addEventListener('click', exportData);
        importDataInput.addEventListener('change', handleImportData);
        // Pomodoro Settings Listeners
        pomodoroSettingsToggleBtn.addEventListener('click', () => {
            const isActive = pomodoroSettingsDiv.classList.toggle('active');
            if (isActive) {
                settingWorkMinsInput.value = currentWorkMins;
                settingShortBreakMinsInput.value = currentShortBreakMins;
                settingLongBreakMinsInput.value = currentLongBreakMins;
            }
        });
        pomodoroSaveSettingsBtn.addEventListener('click', handleSavePomodoroSettings);

    </script>

</body>
</html>
