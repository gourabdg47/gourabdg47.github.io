<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Kanban Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DN4GBMQMRM"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-DN4GBMQMRM');
    </script>

    <style>
        /* Base styling */
        html, body { height: 100%; font-family: 'Nunito', sans-serif; scroll-behavior: smooth; }
        body { background-color: #f8fafc; /* slate-50 */ transition: background-color 0.5s ease; }

        /* Pomodoro Timer Panel */
        .pomodoro-panel {
            position: relative; /* Needed for absolute positioning of progress bar */
            overflow: hidden; /* Hide overflowing progress bar/waves */
            background-color: white;
            border-radius: 0.5rem;
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            transition: opacity 0.5s ease, transform 0.5s ease;
            z-index: 1;
        }
        /* Progress Bar */
        #pomodoro-progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background-color: rgba(134, 239, 172, 0.4); /* Light green with transparency (green-300) */
            transform-origin: right center;
            transform: scaleX(0);
            transition: transform 0.5s linear;
            z-index: -1;
            overflow: hidden;
        }
        #pomodoro-progress-bar::after { /* Wave effect */
             content: '';
             position: absolute;
             width: 200%;
             height: 100%;
             top: 0;
             left: 0;
             background: linear-gradient(
               -45deg,
               rgba(255, 255, 255, 0.1) 25%,
               transparent 25%,
               transparent 50%,
               rgba(255, 255, 255, 0.1) 50%,
               rgba(255, 255, 255, 0.1) 75%,
               transparent 75%,
               transparent
             );
             background-size: 50px 50px;
             opacity: 0.5;
             animation: wave-animation 4s linear infinite;
             z-index: 1;
        }

        @keyframes wave-animation {
            0% { background-position: 0 0; }
            100% { background-position: 100px 0; }
        }

        .pomodoro-main-controls { position: relative; z-index: 2; display: flex; flex-direction: column; align-items: center; width: 100%; gap: 0.75rem;}
        @media (min-width: 768px) { .pomodoro-main-controls { flex-direction: row; justify-content: space-between; } }
        .pomodoro-display { font-size: 2.25rem; font-weight: 700; color: #1f2937; font-family: 'Menlo', 'Monaco', 'Consolas', "Courier New", monospace; line-height: 1; }
        .pomodoro-status { font-size: 0.875rem; font-weight: 600; padding: 0.25rem 0.75rem; border-radius: 9999px; text-transform: uppercase; letter-spacing: 0.05em; }
        .pomodoro-status.work { background-color: #fef3c7; color: #b45309; } /* amber-100, amber-700 */
        .pomodoro-status.break { background-color: #dcfce7; color: #166534; } /* green-100, green-700 */
        .pomodoro-controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.5rem; align-items: center;}
        .pomodoro-controls button { padding: 0.5rem 1rem; font-size: 0.875rem; }
        .pomodoro-controls button i { margin-right: 0.375rem; }
        .pomodoro-controls button:disabled { opacity: 0.5; cursor: not-allowed; }
        .pomodoro-controls .btn-icon i { margin-right: 0; }

        /* Pomodoro Settings Section */
        .pomodoro-settings { position: relative; z-index: 2; display: none; width: 100%; border-top: 1px solid #e5e7eb; margin-top: 1rem; padding-top: 1rem; gap: 1.5rem; flex-direction: column; align-items: center; }
        .pomodoro-settings.active { display: flex; }
        .pomodoro-settings-grid { display: grid; grid-template-columns: repeat(1, 1fr); gap: 1rem; width: 100%; max-width: 500px; }
        @media (min-width: 480px) { .pomodoro-settings-grid { grid-template-columns: repeat(2, 1fr); } }
        .pomodoro-settings-section { display: flex; flex-direction: column; gap: 0.5rem; }
        .pomodoro-settings-section h4 { font-size: 0.9rem; font-weight: 600; color: #4b5563; margin-bottom: 0.25rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.25rem;}
        .pomodoro-settings-item { display: flex; flex-direction: column; gap: 0.1rem; }
        .pomodoro-settings-item label { font-size: 0.8rem; color: #4b5563; display: block; margin-bottom: 0.1rem;}
        .pomodoro-settings-item input[type="number"] { width: 100%; padding: 0.375rem 0.5rem; border: 1px solid #d1d5db; border-radius: 0.25rem; font-size: 0.875rem; text-align: center; -moz-appearance: textfield; }
        .pomodoro-settings-item input[type="number"]::-webkit-outer-spin-button,
        .pomodoro-settings-item input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .pomodoro-settings-toggle-item { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; margin-top: 0.5rem; }
        .pomodoro-settings-toggle-item label { font-size: 0.8rem; color: #4b5563; margin-bottom: 0; flex-grow: 1; /* Allow label to take space */ }
        /* Toggle Switch Styles */
        .pomodoro-settings-toggle-item input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            position: relative;
            width: 3rem; /* Width of the toggle track */
            height: 1.5rem; /* Height of the toggle track */
            background-color: #e5e7eb; /* bg-gray-200 */
            border-radius: 9999px; /* Fully rounded */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .pomodoro-settings-toggle-item input[type="checkbox"]::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 1.25rem; /* Size of the handle */
            height: 1.25rem;
            background-color: white;
            border-radius: 50%; /* Circular handle */
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            transition: transform 0.2s ease-in-out;
        }
        .pomodoro-settings-toggle-item input[type="checkbox"]:checked {
            background-color: #60a5fa; /* bg-blue-400 */
        }
        .pomodoro-settings-toggle-item input[type="checkbox"]:checked::before {
            transform: translateX(calc(3rem - 1.5rem)); /* Move handle to the right (track width - handle width) */
        }
        .pomodoro-settings-actions { display: flex; justify-content: center; width: 100%; margin-top: 1rem; }
        .pomodoro-settings-actions button { font-size: 0.875rem; padding: 0.5rem 1rem;}

        /* Add Task Panel - Calm Colors */
        #add-task-panel {
            transition: opacity 0.5s ease, transform 0.5s ease;
            background-color: #eff6ff; /* bg-blue-50 */
            border-color: #dbeafe; /* border-blue-100 */
        }
        #add-task-panel h2 {
            color: #1e40af; /* text-blue-800 */
        }
        #add-task-panel input[type="text"] {
            border-color: #bfdbfe; /* border-blue-200 */
            background-color: white;
        }
        #add-task-panel input[type="text"]:focus {
            border-color: #60a5fa; /* focus:border-blue-400 */
            --tw-ring-color: rgba(96, 165, 250, 0.5); /* focus:ring-blue-300 with opacity */
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
        }
        #add-task-panel #addTaskBtn {
            background-color: #60a5fa; /* bg-blue-400 */
            border-color: #60a5fa;
            color: white;
        }
        #add-task-panel #addTaskBtn:hover:not(:disabled) {
            background-color: #3b82f6; /* bg-blue-500 */
            border-color: #3b82f6;
        }
        /* Keep export/import buttons secondary */
        #add-task-panel .data-actions .btn-secondary {
             background-color: #e5e7eb; color: #374151; border-color: #d1d5db;
        }
         #add-task-panel .data-actions .btn-secondary:hover:not(:disabled) {
             background-color: #d1d5db; border-color: #9ca3af;
         }


        /* Kanban Column Styling */
        .kanban-column { min-height: 350px; display: flex; flex-direction: column; transition: background-color 0.2s ease, box-shadow 0.3s ease, opacity 0.5s ease, transform 0.5s ease; border-radius: 0.5rem; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); overflow: hidden; }
        .column-header { padding: 0.75rem 1rem; border-bottom-width: 1px; font-weight: 700; font-size: 1rem; display: flex; align-items: center; }
        .tasks-container { flex-grow: 1; padding: 0.75rem; overflow-y: auto; }
        .tasks-container > .kanban-task + .kanban-task { margin-top: 0.75rem; }

        /* Done Column Glow Effect */
        .kanban-column.done-glow { animation: pulse-glow 2.5s infinite ease-in-out; }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0px 0px rgba(34, 197, 94, 0.3), 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
            50% { box-shadow: 0 0 10px 4px rgba(34, 197, 94, 0.4), 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
        }

        /* Task Card Styling */
        .kanban-task { cursor: grab; transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, border-left-color 0.3s ease, opacity 0.3s ease; position: relative; padding: 0.625rem 2.25rem 0.625rem 1rem; border-radius: 0.375rem; background-color: white; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.07); display: flex; align-items: start; border-left: 3px solid #cbd5e1; }
        .kanban-task:hover { box-shadow: 0 4px 8px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06); border-left-color: #94a3b8; }
        .kanban-task:hover .task-actions { opacity: 1; }
        .kanban-task:active { cursor: grabbing; transform: scale(1.02); box-shadow: 0 8px 12px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .dragging { opacity: 0.7; transform: rotate(2deg); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .drag-over { background-color: rgba(100, 116, 139, 0.06); }

        /* Task Active State */
        .kanban-task.is-active { border-left-color: #fbbf24; animation: pulse-opacity 3s infinite ease-in-out; }
        @keyframes pulse-opacity { 0%, 100% { opacity: 1; } 50% { opacity: 0.9; } }

        /* Task Content */
        .task-content { display: flex; flex-direction: column; flex-grow: 1; margin-right: 0.25rem; word-break: break-word; }
        .task-text { line-height: 1.4; color: #374151; font-size: 0.9rem; margin-bottom: 0.25rem; }
        .task-labels { display: flex; flex-wrap: wrap; gap: 0.25rem; margin-bottom: 0.25rem; }
        .task-label { background-color: #e0e7ff; color: #3730a3; padding: 0.125rem 0.5rem; font-size: 0.65rem; border-radius: 9999px; font-weight: 600; }
        .task-timer-area { margin-top: auto; font-size: 0.7rem; color: #6b7280; font-family: 'Menlo', 'Monaco', 'Consolas', "Courier New", monospace; min-height: 1em; display: flex; flex-direction: column; gap: 0.125rem; }
        .task-timer { display: flex; align-items: center; }
        .task-timer i { margin-right: 0.25rem; color: #9ca3af; flex-shrink: 0; }

        /* Task Action Buttons */
        .task-actions { position: absolute; top: 0.375rem; right: 0.375rem; display: flex; flex-direction: column; gap: 0.25rem; opacity: 0.3; transition: opacity 0.2s ease-in-out; }
        .kanban-task:hover .task-actions { opacity: 1; }
        .task-action-btn { background-color: #f9fafb; border: 1px solid #e5e7eb; cursor: pointer; padding: 0.125rem; color: #6b7280; border-radius: 9999px; transition: all 0.15s ease-in-out; line-height: 1; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center; box-shadow: none; }
        .task-action-btn i { font-size: 0.65rem; }
        .task-action-btn:hover { background-color: #f3f4f6; color: #1f2937; border-color: #d1d5db; transform: scale(1.1); box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
        .task-action-btn.delete-btn:hover { background-color: #fee2e2; color: #ef4444; border-color: #fecaca; }
        .task-action-btn.edit-btn:hover { background-color: #dbeafe; color: #3b82f6; border-color: #bfdbfe; }
        .task-action-btn:active { transform: scale(0.95); filter: brightness(0.95); }

        /* Inline Editing */
        .editing-container { display: flex; flex-direction: column; gap: 0.5rem; width: 100%; }
        .editing-input { padding: 0.25rem 0.375rem; border: 1px solid #3b82f6; border-radius: 0.25rem; outline: none; font-size: 0.9rem; font-family: inherit; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); width: 100%; }
        .editing-input::placeholder { color: #9ca3af; font-size: 0.8rem;}

        /* Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 10000; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal-content { background-color: white; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); max-width: 400px; width: 90%; text-align: center; transform: scale(0.95); transition: transform 0.2s ease; }
        .modal-overlay.active .modal-content { transform: scale(1); }

        /* Custom Scrollbar */
        .tasks-container::-webkit-scrollbar { width: 6px; }
        .tasks-container::-webkit-scrollbar-track { background: transparent; }
        .tasks-container::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 10px; }
        .tasks-container::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

        /* Button Styling (General) */
        .btn { display: inline-flex; align-items: center; justify-content: center; padding: 0.625rem 1.25rem; border-radius: 0.375rem; font-weight: 600; transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s, opacity 0.2s; border: 1px solid transparent; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); cursor: pointer; }
        .btn:active { transform: scale(0.98); }
        .btn-primary { background-color: #2563eb; color: white; border-color: #2563eb; } /* Default primary */
        .btn-primary:hover:not(:disabled) { background-color: #1d4ed8; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .btn-danger { background-color: #dc2626; color: white; border-color: #dc2626; }
        .btn-danger:hover:not(:disabled) { background-color: #b91c1c; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .btn-secondary { background-color: #e5e7eb; color: #374151; border-color: #d1d5db; }
        .btn-secondary:hover:not(:disabled) { background-color: #d1d5db; border-color: #9ca3af; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .btn-clear { padding: 0.25rem 0.5rem; font-size: 0.75rem; color: #dc2626; background-color: transparent; border: none; box-shadow: none; font-weight: 500; border-radius: 0.25rem; transition: background-color 0.2s, color 0.2s; }
        .btn-clear:hover { background-color: #fee2e2; color: #b91c1c; }
        .btn i { margin-right: 0.5rem; }
        .btn-icon { padding: 0.5rem; width: 2.25rem; height: 2.25rem; border-radius: 9999px; }
        .btn-icon i { margin-right: 0; font-size: 0.875rem; }

        /* --- Zen Mode Styles --- */
        .zen-mode-active #add-task-panel,
        .zen-mode-active #todo,
        .zen-mode-active #inprogress,
        .zen-mode-active #done,
        .zen-mode-active .pomodoro-panel,
        .zen-mode-active .bmc-button {
            opacity: 0.15;
            pointer-events: none;
            transform: scale(0.98);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .zen-mode-active.zen-target-inprogress #inprogress {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
            animation: pulse-calm 3s infinite ease-in-out;
        }
        .zen-mode-active.zen-target-todo #todo {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
            animation: none;
        }
        .zen-mode-active .pomodoro-panel { /* Keep Pomodoro panel visible */
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
            animation: none;
        }
        @keyframes pulse-calm {
            0%, 100% { box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
            50% { box-shadow: 0 4px 10px -1px rgba(251, 191, 36, 0.25), 0 2px 6px -2px rgba(251, 191, 36, 0.2); }
        }

        /* --- Buy Me a Coffee Button Styles --- */
        .bmc-button {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 1000;
            padding: 0.6rem;
            width: 3rem;
            height: 3rem;
            background-color: #FFDD00;
            color: #000000;
            border-radius: 9999px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s ease-out, box-shadow 0.2s ease, opacity 0.5s ease;
            animation: bmc-float 3s ease-in-out infinite;
        }

        .bmc-button img {
            height: 1.75em;
            width: 1.75em;
        }

        .bmc-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            animation-play-state: paused;
        }

        @keyframes bmc-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }

    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <div class="pomodoro-panel">
             <div id="pomodoro-progress-bar"></div>
             <div class="pomodoro-main-controls">
                 <div class="flex items-center gap-4">
                     <span id="pomodoro-display" class="pomodoro-display">25:00</span>
                     <span id="pomodoro-status" class="pomodoro-status work">Work</span>
                 </div>
                 <div class="pomodoro-controls">
                     <button id="pomodoro-start" class="btn btn-primary btn-sm"><i class="fas fa-play"></i>Start</button>
                     <button id="pomodoro-pause" class="btn btn-secondary btn-sm" style="display: none;"><i class="fas fa-pause"></i>Pause</button>
                     <button id="pomodoro-reset" class="btn btn-secondary btn-sm"><i class="fas fa-redo"></i>Reset</button>
                     <button id="pomodoro-settings-toggle" class="btn btn-secondary btn-icon btn-sm" title="Pomodoro Settings" aria-label="Pomodoro Settings">
                         <i class="fas fa-cog"></i>
                     </button>
                 </div>
             </div>
             <div id="pomodoro-settings" class="pomodoro-settings">
                 <div class="pomodoro-settings-grid">
                     <div class="pomodoro-settings-section">
                         <h4>Durations (minutes)</h4>
                         <div class="pomodoro-settings-item">
                             <label for="setting-work-mins">Work:</label>
                             <input type="number" id="setting-work-mins" min="1" max="120" step="1">
                         </div>
                         <div class="pomodoro-settings-item">
                             <label for="setting-short-break-mins">Short Break:</label>
                             <input type="number" id="setting-short-break-mins" min="1" max="30" step="1">
                         </div>
                         <div class="pomodoro-settings-item">
                             <label for="setting-long-break-mins">Long Break:</label>
                             <input type="number" id="setting-long-break-mins" min="1" max="60" step="1">
                         </div>
                     </div>
                     <div class="pomodoro-settings-section">
                         <h4>Behavior</h4>
                         <div class="pomodoro-settings-item">
                             <label for="setting-long-break-interval">Cycles before Long Break:</label>
                             <input type="number" id="setting-long-break-interval" min="1" max="10" step="1">
                         </div>
                         <div class="pomodoro-settings-toggle-item">
                             <label for="setting-auto-start-breaks">Auto-start Breaks?</label>
                             <input type="checkbox" id="setting-auto-start-breaks" aria-labelledby="label-auto-start-breaks">
                         </div>
                         <div class="pomodoro-settings-toggle-item">
                             <label for="setting-auto-start-work">Auto-start Work after Break?</label>
                             <input type="checkbox" id="setting-auto-start-work" aria-labelledby="label-auto-start-work">
                         </div>
                         <div class="pomodoro-settings-toggle-item">
                             <label for="setting-enable-sounds">Enable Sounds?</label>
                             <input type="checkbox" id="setting-enable-sounds" aria-labelledby="label-enable-sounds">
                         </div>
                         <div class="pomodoro-settings-toggle-item">
                             <label for="setting-enable-zen-mode">Enable Zen Mode?</label>
                             <input type="checkbox" id="setting-enable-zen-mode" aria-labelledby="label-enable-zen-mode">
                         </div>
                     </div>
                 </div>
                 <div class="pomodoro-settings-actions">
                     <button id="pomodoro-save-settings" class="btn btn-primary btn-sm">Save Settings</button>
                 </div>
             </div>
        </div>

        <div id="add-task-panel" class="mb-6 md:mb-8 bg-blue-50 p-4 rounded-lg shadow-sm border border-blue-100">
            <h2 class="text-lg font-semibold mb-3 text-blue-800">Add New Task</h2>
            <div class="flex flex-col sm:flex-row gap-3 mb-3">
                <input type="text" id="newTaskInput" placeholder="Enter task (try breaking large tasks down!)" class="flex-grow p-2.5 border border-blue-200 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-300 focus:border-blue-400 transition shadow-sm bg-white" aria-label="New task description">
                <input type="text" id="newTaskLabels" placeholder="Labels (comma-separated)..." class="p-2.5 border border-blue-200 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-300 focus:border-blue-400 transition shadow-sm bg-white sm:w-1/3" aria-label="New task labels">
            </div>
            <div class="flex flex-col sm:flex-row gap-3 items-center">
                 <button id="addTaskBtn" class="btn btn-primary flex-grow sm:flex-grow-0"> <i class="fas fa-plus fa-sm"></i>Add Task
                 </button>
                 <div class="data-actions flex gap-2 ml-auto">
                     <button id="exportDataBtn" class="btn btn-secondary btn-icon" title="Export Data (JSON)" aria-label="Export Data">
                         <i class="fas fa-download"></i>
                     </button>
                     <label for="importDataInput" class="btn btn-secondary btn-icon cursor-pointer" title="Import Data (JSON)" aria-label="Import Data">
                         <i class="fas fa-upload"></i>
                     </label>
                     <input type="file" id="importDataInput" accept=".json" style="display: none;">
                 </div>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 md:gap-6">
            <div id="todo" class="kanban-column bg-blue-50">
                <h2 class="column-header text-blue-800 border-blue-200"><i class="fas fa-list-ul mr-2 text-blue-500"></i>To Do</h2>
                <div class="tasks-container"></div>
            </div>
            <div id="inprogress" class="kanban-column bg-yellow-50">
                <h2 class="column-header text-yellow-800 border-yellow-200"><i id="inprogress-spinner" class="fas fa-spinner mr-2 text-yellow-600"></i>In Progress</h2>
                <div class="tasks-container"></div>
            </div>
            <div id="done" class="kanban-column bg-green-50">
                 <div class="column-header flex justify-between items-center text-green-800 border-green-200">
                     <span><i class="fas fa-check-circle mr-2 text-green-600"></i>Done</span>
                     <button id="clearDoneBtn" title="Clear all done tasks" class="btn-clear"><i class="fas fa-trash-alt mr-1"></i> Clear All</button>
                 </div>
                 <div class="tasks-container"></div>
            </div>
        </div>
    </div>

    <a href="https://buymeacoffee.com/gourabdg" target="_blank" rel="noopener noreferrer" class="bmc-button" title="Support the developer!">
        <img src="https://www.buymeacoffee.com/assets/img/guidelines/logo-mark-3.svg" alt="Buy Me a Coffee logo" />
    </a>

    <canvas id="confettiCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;"></canvas>

    <div id="confirmationModal" class="modal-overlay">
        <div class="modal-content">
            <p id="modalMessage" class="mb-5 text-gray-700 text-lg">Are you sure?</p>
            <div class="flex justify-center gap-4">
                <button id="confirmBtn" class="btn btn-danger">Confirm</button>
                <button id="cancelBtn" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element Selection ---
        const addTaskPanel = document.getElementById('add-task-panel');
        const newTaskInput = document.getElementById('newTaskInput');
        const newTaskLabels = document.getElementById('newTaskLabels');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const columns = document.querySelectorAll('.kanban-column');
        const tasksContainers = document.querySelectorAll('.tasks-container');
        const todoTasksContainer = document.getElementById('todo').querySelector('.tasks-container');
        const inprogressTasksContainer = document.getElementById('inprogress').querySelector('.tasks-container');
        const doneTasksContainer = document.getElementById('done').querySelector('.tasks-container');
        const inprogressSpinner = document.getElementById('inprogress-spinner');
        const doneColumn = document.getElementById('done');
        const clearDoneBtn = document.getElementById('clearDoneBtn');
        const confettiCanvas = document.getElementById('confettiCanvas');
        const confirmationModal = document.getElementById('confirmationModal');
        const modalMessage = document.getElementById('modalMessage');
        const confirmBtn = document.getElementById('confirmBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const pomodoroPanel = document.querySelector('.pomodoro-panel');
        const pomodoroDisplay = document.getElementById('pomodoro-display');
        const pomodoroStatus = document.getElementById('pomodoro-status');
        const pomodoroStartBtn = document.getElementById('pomodoro-start');
        const pomodoroPauseBtn = document.getElementById('pomodoro-pause');
        const pomodoroResetBtn = document.getElementById('pomodoro-reset');
        const pomodoroProgressBar = document.getElementById('pomodoro-progress-bar');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataInput = document.getElementById('importDataInput');
        const pomodoroSettingsToggleBtn = document.getElementById('pomodoro-settings-toggle');
        const pomodoroSettingsDiv = document.getElementById('pomodoro-settings');
        const settingWorkMinsInput = document.getElementById('setting-work-mins');
        const settingShortBreakMinsInput = document.getElementById('setting-short-break-mins');
        const settingLongBreakMinsInput = document.getElementById('setting-long-break-mins');
        const settingLongBreakIntervalInput = document.getElementById('setting-long-break-interval');
        const settingAutoStartBreaksInput = document.getElementById('setting-auto-start-breaks');
        const settingAutoStartWorkInput = document.getElementById('setting-auto-start-work');
        const settingEnableSoundsInput = document.getElementById('setting-enable-sounds');
        const settingEnableZenModeInput = document.getElementById('setting-enable-zen-mode'); // New Zen Mode Toggle
        const pomodoroSaveSettingsBtn = document.getElementById('pomodoro-save-settings');
        const bmcButton = document.querySelector('.bmc-button');

        // --- Global Variables & Instances ---
        const myConfetti = confetti.create(confettiCanvas, { resize: true, useWorker: true });
        const activeTaskTimers = {};
        let draggedItem = null;
        let sourceColumnId = null;
        let confirmCallback = null;

        // --- Default Pomodoro Settings ---
        const DEFAULT_WORK_MINS = 25;
        const DEFAULT_SHORT_BREAK_MINS = 5;
        const DEFAULT_LONG_BREAK_MINS = 15;
        const DEFAULT_LONG_BREAK_INTERVAL = 4;
        const DEFAULT_AUTO_START_BREAKS = true;
        const DEFAULT_AUTO_START_WORK = true;
        const DEFAULT_ENABLE_SOUNDS = true;
        const DEFAULT_ENABLE_ZEN_MODE = true; // Default Zen Mode to enabled

        // --- Pomodoro Settings (loaded from localStorage) ---
        let currentWorkMins = DEFAULT_WORK_MINS;
        let currentShortBreakMins = DEFAULT_SHORT_BREAK_MINS;
        let currentLongBreakMins = DEFAULT_LONG_BREAK_MINS;
        let currentLongBreakInterval = DEFAULT_LONG_BREAK_INTERVAL;
        let currentAutoStartBreaks = DEFAULT_AUTO_START_BREAKS;
        let currentAutoStartWork = DEFAULT_AUTO_START_WORK;
        let currentEnableSounds = DEFAULT_ENABLE_SOUNDS;
        let currentEnableZenMode = DEFAULT_ENABLE_ZEN_MODE; // New Zen Mode Setting

        // Pomodoro Timer State
        const POMODORO_STATES = { WORK: 'Work', SHORT_BREAK: 'Break', LONG_BREAK: 'Break' };
        let pomodoroIntervalId = null;
        let pomodoroState = POMODORO_STATES.WORK;
        let pomodoroTimeLeft = currentWorkMins * 60;
        let pomodoroTotalDuration = currentWorkMins * 60;
        let pomodoroCycles = 0;

        // --- Sound Synthesis (Tone.js) ---
        let soundsReady = false;
        let taskCompleteSynth = null;
        let pomodoroEndSynth = null;

        const initAudio = () => {
            if (soundsReady) return;
            Tone.start().then(() => {
                taskCompleteSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 } }).toDestination();
                pomodoroEndSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.2, release: 0.8 } }).toDestination();
                console.log("Audio ready."); soundsReady = true;
            }).catch(e => console.error("Tone.start failed:", e));
        };
        const playTaskCompleteSound = () => {
            if (!soundsReady || !taskCompleteSynth || !currentEnableSounds) return;
            try { taskCompleteSynth.triggerAttackRelease("C5", "8n", Tone.now()); taskCompleteSynth.triggerAttackRelease("G5", "8n", Tone.now() + 0.15); }
            catch (e) { console.error("Error playing task complete sound:", e); }
        };
        const playPomodoroEndSound = () => {
             if (!soundsReady || !pomodoroEndSynth || !currentEnableSounds) return;
             try { pomodoroEndSynth.triggerAttackRelease("E4", "4n", Tone.now()); pomodoroEndSynth.triggerAttackRelease("G4", "4n", Tone.now() + 0.3); }
             catch (e) { console.error("Error playing pomodoro end sound:", e); }
        };


        // --- Helper Functions ---
        const formatPomodoroTime = (totalSeconds) => {
            const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        };
        const updatePomodoroDisplay = () => {
            pomodoroDisplay.textContent = formatPomodoroTime(pomodoroTimeLeft);
            document.title = `${formatPomodoroTime(pomodoroTimeLeft)} - ${pomodoroState} | Kanban`;
        };
        const updatePomodoroStatus = () => {
            pomodoroStatus.textContent = pomodoroState;
            pomodoroStatus.className = `pomodoro-status ${pomodoroState === POMODORO_STATES.WORK ? 'work' : 'break'}`;
        };
        const setPomodoroControlsState = (isRunning) => {
            pomodoroStartBtn.disabled = isRunning;
            pomodoroPauseBtn.disabled = !isRunning;
            pomodoroResetBtn.disabled = isRunning;
            pomodoroSettingsToggleBtn.disabled = isRunning;
        };

        /** Updates the body classes based on Zen Mode setting and timer state. */
        const updateZenMode = () => {
            // Always remove classes first
            document.body.classList.remove('zen-mode-active', 'zen-target-inprogress', 'zen-target-todo');

            // Exit if Zen Mode is disabled in settings
            if (!currentEnableZenMode) {
                return;
            }

            const isRunning = pomodoroIntervalId !== null;
            const isWorkState = pomodoroState === POMODORO_STATES.WORK;
            const inProgressHasTasks = inprogressTasksContainer.children.length > 0;

            if (isRunning && isWorkState) {
                document.body.classList.add('zen-mode-active');
                if (inProgressHasTasks) {
                    document.body.classList.add('zen-target-inprogress');
                } else {
                    document.body.classList.add('zen-target-todo');
                }
            }
            // No need for an else here, classes were removed at the start
        };

        const updateProgressBar = () => {
            if (!pomodoroProgressBar || pomodoroTotalDuration <= 0) return;
            const progress = Math.max(0, pomodoroTimeLeft / pomodoroTotalDuration);
            pomodoroProgressBar.style.transform = `scaleX(${progress})`;
        };

        const resetPomodoroTimerTime = (forceUpdateDisplay = true) => {
            clearInterval(pomodoroIntervalId); pomodoroIntervalId = null;

            switch (pomodoroState) {
                case POMODORO_STATES.WORK:
                    pomodoroTimeLeft = currentWorkMins * 60;
                    pomodoroTotalDuration = currentWorkMins * 60;
                    break;
                case POMODORO_STATES.SHORT_BREAK:
                    pomodoroTimeLeft = currentShortBreakMins * 60;
                    pomodoroTotalDuration = currentShortBreakMins * 60;
                    break;
                case POMODORO_STATES.LONG_BREAK:
                    pomodoroTimeLeft = currentLongBreakMins * 60;
                    pomodoroTotalDuration = currentLongBreakMins * 60;
                    break;
                default:
                    pomodoroTotalDuration = currentWorkMins * 60;
            }

            if (forceUpdateDisplay) {
                updatePomodoroDisplay(); updatePomodoroStatus();
                pomodoroStartBtn.style.display = 'inline-flex'; pomodoroPauseBtn.style.display = 'none';
                setPomodoroControlsState(false); document.title = "Focus Kanban Tracker";
            }

            if (pomodoroProgressBar) {
                pomodoroProgressBar.style.transition = 'none';
                pomodoroProgressBar.style.transform = 'scaleX(0)';
                void pomodoroProgressBar.offsetWidth;
                pomodoroProgressBar.style.transition = 'transform 0.5s linear';
            }
            updateZenMode();
        };
        const handlePomodoroReset = () => {
            pomodoroState = POMODORO_STATES.WORK;
            pomodoroCycles = 0;
            resetPomodoroTimerTime();
        };
        const nextPomodoroState = () => {
            playPomodoroEndSound();
            let shouldAutoStart = false;
            let previousState = pomodoroState;

            if (pomodoroState === POMODORO_STATES.WORK) {
                pomodoroCycles++;
                pomodoroState = (pomodoroCycles % currentLongBreakInterval === 0)
                    ? POMODORO_STATES.LONG_BREAK
                    : POMODORO_STATES.SHORT_BREAK;
                shouldAutoStart = currentAutoStartBreaks;
            } else {
                pomodoroState = POMODORO_STATES.WORK;
                shouldAutoStart = currentAutoStartWork;
            }

            if (pomodoroState === POMODORO_STATES.WORK && previousState !== POMODORO_STATES.WORK) {
               pomodoroCycles = 0;
            }

            resetPomodoroTimerTime();

            if (shouldAutoStart) {
                startPomodoro();
            }
        };
        const startPomodoro = () => {
            initAudio();
            if (pomodoroIntervalId) return;

            resetPomodoroTimerTime(false); // Set correct duration for progress bar

            pomodoroStartBtn.style.display = 'none'; pomodoroPauseBtn.style.display = 'inline-flex';
            setPomodoroControlsState(true);

            if (pomodoroProgressBar) {
                 pomodoroProgressBar.style.transition = 'none';
                 pomodoroProgressBar.style.transform = 'scaleX(1)';
                 void pomodoroProgressBar.offsetWidth;
                 pomodoroProgressBar.style.transition = 'transform 0.5s linear';
            }

            pomodoroIntervalId = setInterval(() => {
                pomodoroTimeLeft--;
                updatePomodoroDisplay();
                updateProgressBar();

                if (pomodoroTimeLeft <= 0) {
                    clearInterval(pomodoroIntervalId); pomodoroIntervalId = null; nextPomodoroState();
                }
            }, 1000);

            updateZenMode();
        };
        const pausePomodoro = () => {
            clearInterval(pomodoroIntervalId); pomodoroIntervalId = null;
            pomodoroStartBtn.style.display = 'inline-flex'; pomodoroPauseBtn.style.display = 'none';
            setPomodoroControlsState(false);
            updateZenMode();
        };
        const formatTaskTime = (ms) => {
            if (ms === null || ms === undefined || ms < 0) return '';
            let s = Math.floor(ms / 1000); let m = Math.floor(s / 60); let h = Math.floor(m / 60); let d = Math.floor(h / 24);
            s %= 60; m %= 60; h %= 24; let p = [];
            if (d > 0) p.push(`${d}D`); if (h > 0 || d > 0) p.push(`${h}H`); if (m > 0 || h > 0 || d > 0) p.push(`${m}m`); p.push(`${s}s`);
            return p.join(':');
        };

        // --- Task Work Timer Functions ---
        const updateTaskTimerDisplay = (taskElement, startTime) => {
            const timerDiv = taskElement.querySelector('.task-timer');
            if (!timerDiv || !startTime) return;
            const elapsed = Date.now() - startTime;
            timerDiv.innerHTML = `<i class="fas fa-stopwatch fa-xs"></i> ${formatTaskTime(elapsed)}`;
            timerDiv.style.display = 'flex';
        };
        const startTaskTimerInterval = (taskElement, startTime) => {
            const taskId = taskElement.id; stopTaskTimerInterval(taskElement);
            updateTaskTimerDisplay(taskElement, startTime);
            activeTaskTimers[taskId] = setInterval(() => updateTaskTimerDisplay(taskElement, startTime), 1000);
            taskElement.dataset.timerStartTime = startTime;
            taskElement.classList.add('is-active');
        };
        const stopTaskTimerInterval = (taskElement) => {
            const taskId = taskElement.id;
            if (activeTaskTimers[taskId]) { clearInterval(activeTaskTimers[taskId]); delete activeTaskTimers[taskId]; }
            taskElement.classList.remove('is-active');
        };
        const displayTotalTaskTime = (taskElement, totalTimeMs) => {
            const timerDiv = taskElement.querySelector('.task-timer');
            if (timerDiv) {
                if (totalTimeMs !== null && totalTimeMs >= 0) {
                    timerDiv.innerHTML = `<i class="fas fa-check-circle fa-xs text-green-600"></i> Total: ${formatTaskTime(totalTimeMs)}`;
                    timerDiv.style.display = 'flex';
                } else {
                    timerDiv.innerHTML = ''; timerDiv.style.display = 'none';
                }
            }
        };
        const pauseWorkTimer = (taskElement) => {
            const startTime = taskElement.dataset.timerStartTime ? parseInt(taskElement.dataset.timerStartTime, 10) : null;
            if (startTime) {
                const elapsed = Date.now() - startTime;
                let currentTotalTime = parseInt(taskElement.dataset.totalTime || '0', 10);
                taskElement.dataset.totalTime = currentTotalTime + elapsed;
                delete taskElement.dataset.timerStartTime;
            }
            stopTaskTimerInterval(taskElement);
            const totalTime = parseInt(taskElement.dataset.totalTime || '0', 10);
            displayTotalTaskTime(taskElement, totalTime);
        };

        // --- Task Element Creation & Management ---
        const createTaskElement = (taskData) => {
            const { id, text, labels = [], startTime = null, totalTime = 0 } = taskData;
            const task = document.createElement('div');
            task.className = 'kanban-task'; task.draggable = true;
            task.id = id || `task-${Date.now()}`;
            task.dataset.totalTime = totalTime || 0;
            task.dataset.labels = JSON.stringify(labels);

            const contentDiv = document.createElement('div'); contentDiv.className = 'task-content';
            const textSpan = document.createElement('span'); textSpan.className = 'task-text'; textSpan.textContent = text;
            contentDiv.appendChild(textSpan);
            const labelsDiv = document.createElement('div'); labelsDiv.className = 'task-labels';
            labels.forEach(label => {
                const labelSpan = document.createElement('span');
                labelSpan.className = 'task-label';
                labelSpan.textContent = label;
                labelsDiv.appendChild(labelSpan);
            });
            contentDiv.appendChild(labelsDiv);
            const timerAreaDiv = document.createElement('div'); timerAreaDiv.className = 'task-timer-area';
            const timerDiv = document.createElement('div'); timerDiv.className = 'task-timer'; timerDiv.style.display = 'none';
            timerAreaDiv.appendChild(timerDiv);
            contentDiv.appendChild(timerAreaDiv);
            task.appendChild(contentDiv);

            const actionsDiv = document.createElement('div'); actionsDiv.className = 'task-actions';
            const editBtn = document.createElement('button'); editBtn.className = 'task-action-btn edit-btn'; editBtn.innerHTML = '<i class="fas fa-pencil-alt fa-xs"></i>'; editBtn.title = "Edit task"; editBtn.setAttribute('aria-label', 'Edit task');
            editBtn.addEventListener('click', (e) => { e.stopPropagation(); enableEditing(task, contentDiv); });
            actionsDiv.appendChild(editBtn);
            const deleteBtn = document.createElement('button'); deleteBtn.className = 'task-action-btn delete-btn'; deleteBtn.innerHTML = '<i class="fas fa-trash-alt fa-xs"></i>'; deleteBtn.title = "Delete task"; deleteBtn.setAttribute('aria-label', 'Delete task');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation(); const currentText = task.querySelector('.task-text').textContent;
                showConfirmationModal(`Delete task: "${currentText}"?`, () => {
                    stopTaskTimerInterval(task);
                    const parentColumnId = task.closest('.kanban-column')?.id;
                    task.remove();
                    updateBoardState();
                    saveTasks();
                    if (parentColumnId === 'inprogress' && pomodoroIntervalId !== null && pomodoroState === POMODORO_STATES.WORK) {
                        updateZenMode();
                    }
                });
            });
            actionsDiv.appendChild(deleteBtn);
            task.appendChild(actionsDiv);

            task.addEventListener('dragstart', handleDragStart); task.addEventListener('dragend', handleDragEnd);
            return task;
        };
        const enableEditing = (taskElement, contentDiv) => {
            const textSpan = contentDiv.querySelector('.task-text');
            const labelsDiv = contentDiv.querySelector('.task-labels');
            const timerArea = contentDiv.querySelector('.task-timer-area');
            const currentText = textSpan.textContent;
            const currentLabels = JSON.parse(taskElement.dataset.labels || '[]');
            const editContainer = document.createElement('div');
            editContainer.className = 'editing-container';
            const textInput = document.createElement('input');
            textInput.type = 'text'; textInput.value = currentText;
            textInput.className = 'editing-input';
            textInput.setAttribute('aria-label', 'Edit task description');
            editContainer.appendChild(textInput);
            const labelsInput = document.createElement('input');
            labelsInput.type = 'text'; labelsInput.value = currentLabels.join(', ');
            labelsInput.placeholder = 'Labels (comma-separated)...';
            labelsInput.className = 'editing-input';
            labelsInput.setAttribute('aria-label', 'Edit task labels');
            editContainer.appendChild(labelsInput);
            textSpan.style.display = 'none'; labelsDiv.style.display = 'none'; if(timerArea) timerArea.style.display = 'none';
            contentDiv.insertBefore(editContainer, textSpan); textInput.select();
            const saveEdit = () => {
                const newText = textInput.value.trim();
                const newLabels = labelsInput.value.split(',').map(label => label.trim()).filter(label => label !== '');
                textSpan.textContent = (newText && newText !== currentText) ? newText : currentText;
                taskElement.dataset.labels = JSON.stringify(newLabels);
                labelsDiv.innerHTML = ''; newLabels.forEach(label => { const labelSpan = document.createElement('span'); labelSpan.className = 'task-label'; labelSpan.textContent = label; labelsDiv.appendChild(labelSpan); });
                contentDiv.removeChild(editContainer); textSpan.style.display = ''; labelsDiv.style.display = 'flex'; if(timerArea) timerArea.style.display = 'flex';
                if ((newText && newText !== currentText) || (JSON.stringify(newLabels) !== JSON.stringify(currentLabels))) {
                    saveTasks();
                }
            };
            let saved = false; const handleSave = () => { if (!saved) { saved = true; saveEdit(); } };
            const handleCancel = () => { if (!saved) { saved = true; contentDiv.removeChild(editContainer); textSpan.style.display = ''; labelsDiv.style.display = 'flex'; if(timerArea) timerArea.style.display = 'flex'; } };
            textInput.addEventListener('blur', handleSave); labelsInput.addEventListener('blur', handleSave);
            editContainer.addEventListener('keypress', (e) => { if (e.key === 'Enter') { handleSave(); } else if (e.key === 'Escape') { handleCancel(); } });
            editContainer.addEventListener('keydown', (e) => { if (e.key === 'Escape') { handleCancel(); } });
        };
        const addTask = () => {
            initAudio();
            const taskText = newTaskInput.value.trim(); const labelText = newTaskLabels.value.trim();
            if (taskText === '') { newTaskInput.focus(); return; }
            const labels = labelText.split(',').map(label => label.trim()).filter(label => label !== '');
            const taskData = { id: `task-${Date.now()}`, text: taskText, labels: labels };
            const newTask = createTaskElement(taskData);
            todoTasksContainer.appendChild(newTask);
            newTaskInput.value = ''; newTaskLabels.value = '';
            saveTasks();
            updateZenMode();
        };

        // --- Drag and Drop Event Handlers ---
        function handleDragStart(e) {
            initAudio();
            if (e.target.querySelector('input:focus') || e.target.querySelector('.editing-input')) { e.preventDefault(); return; }
            draggedItem = e.target; sourceColumnId = draggedItem.closest('.kanban-column').id;
            setTimeout(() => { if(draggedItem) draggedItem.classList.add('dragging'); }, 0);
            e.dataTransfer.effectAllowed = 'move';
            try { e.dataTransfer.setData('text/plain', e.target.id); } catch (error) { console.error("Error setting drag data:", error); }
        }
        function handleDragEnd(e) {
            setTimeout(() => {
                if (draggedItem) { draggedItem.classList.remove('dragging'); }
                draggedItem = null; sourceColumnId = null; columns.forEach(col => col.classList.remove('drag-over'));
            }, 0);
        }
        function handleDragOver(e) {
            e.preventDefault(); e.dataTransfer.dropEffect = 'move';
            const targetColumn = e.currentTarget.closest('.kanban-column');
            columns.forEach(col => { col.classList.toggle('drag-over', col === targetColumn); });
        }
        function handleDragEnter(e) {
             e.preventDefault(); e.currentTarget.closest('.kanban-column').classList.add('drag-over');
        }
        function handleDragLeave(e) {
            const column = e.currentTarget.closest('.kanban-column');
            if (!column || !column.contains(e.relatedTarget)) {
                 if(column) column.classList.remove('drag-over');
            }
        }
        function handleDrop(e) {
            e.preventDefault();
            const dropZoneContainer = e.currentTarget;
            const dropZoneColumn = dropZoneContainer.closest('.kanban-column');
            if (!draggedItem || !dropZoneContainer.classList.contains('tasks-container') || !dropZoneColumn) {
                if (draggedItem) draggedItem.classList.remove('dragging');
                draggedItem = null; sourceColumnId = null;
                columns.forEach(col => col.classList.remove('drag-over'));
                return;
            }

            const destinationColumnId = dropZoneColumn.id;
            const wasInProgress = sourceColumnId === 'inprogress';
            const willBeInProgress = destinationColumnId === 'inprogress';
            const willBeInDone = destinationColumnId === 'done';
            const willBeInTodo = destinationColumnId === 'todo';

            if (wasInProgress && !willBeInProgress) {
                pauseWorkTimer(draggedItem);
            }
            if (!wasInProgress && willBeInProgress) {
                const newWorkStartTime = Date.now();
                startTaskTimerInterval(draggedItem, newWorkStartTime);
            }

            if (willBeInDone) {
                const totalTime = parseInt(draggedItem.dataset.totalTime || '0', 10);
                displayTotalTaskTime(draggedItem, totalTime);
                playTaskCompleteSound();
                triggerConfetti();
            } else if (willBeInTodo) {
                const timerDiv = draggedItem.querySelector('.task-timer');
                if (timerDiv) {
                    timerDiv.innerHTML = '';
                    timerDiv.style.display = 'none';
                }
                draggedItem.classList.remove('is-active');
            }

            const afterElement = getDragAfterElement(dropZoneContainer, e.clientY);
            if (afterElement == null) {
                dropZoneContainer.appendChild(draggedItem);
            } else {
                dropZoneContainer.insertBefore(draggedItem, afterElement);
            }

            dropZoneColumn.classList.remove('drag-over');
            saveTasks();
            updateZenMode();
        }
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.kanban-task:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; } else { return closest; }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- Other Event Handlers ---
        const triggerConfetti = () => { myConfetti({ particleCount: 120, spread: 75, origin: { y: 0.6 }, zIndex: 10000, gravity: 0.8 }); };
        const handleClearDone = () => {
             if (doneTasksContainer.children.length > 0) {
                 showConfirmationModal("Clear all tasks from the 'Done' column?", () => {
                     doneTasksContainer.innerHTML = '';
                     saveTasks();
                 });
             }
        };

        // --- Confirmation Modal ---
        function showConfirmationModal(message, callback) { modalMessage.textContent = message; confirmCallback = callback; confirmationModal.classList.add('active'); }
        function hideConfirmationModal() { confirmationModal.classList.remove('active'); confirmCallback = null; }

        // --- Data Export/Import ---
        const exportData = () => {
            const tasksData = {};
            columns.forEach(column => {
                const columnId = column.id; tasksData[columnId] = [];
                column.querySelectorAll('.kanban-task').forEach(task => {
                    const textSpan = task.querySelector('.task-text');
                    if (textSpan) {
                        tasksData[columnId].push({
                            id: task.id, text: textSpan.textContent, labels: JSON.parse(task.dataset.labels || '[]'),
                            startTime: task.dataset.timerStartTime ? parseInt(task.dataset.timerStartTime, 10) : null,
                            totalTime: parseInt(task.dataset.totalTime || '0', 10)
                        });
                    }
                });
            });
            try {
                const jsonString = JSON.stringify(tasksData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, ''); a.download = `kanban_data_${timestamp}.json`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            } catch (error) { console.error("Error exporting data:", error); alert("Failed to export data. See console for details."); }
        };
        const handleImportData = (event) => {
            const file = event.target.files[0]; if (!file) { return; }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (typeof importedData !== 'object' || importedData === null) { throw new Error("Invalid data format: Not an object."); }
                    const columnIds = Object.keys(importedData); const expectedCols = ['todo', 'inprogress', 'done'];
                    if (!expectedCols.every(col => columnIds.includes(col) && Array.isArray(importedData[col]))) { throw new Error("Invalid data format: Missing or invalid columns."); }
                    showConfirmationModal("Importing data will overwrite the current board. Are you sure?", () => {
                        tasksContainers.forEach(container => container.innerHTML = '');
                        Object.values(activeTaskTimers).forEach(clearInterval); for (const key in activeTaskTimers) { delete activeTaskTimers[key]; }
                        loadTasksFromData(importedData);
                        saveTasks();
                        alert("Data imported successfully!");
                    });
                } catch (error) { console.error("Error importing data:", error); alert(`Failed to import data: ${error.message}`); }
                finally { event.target.value = null; }
            };
            reader.onerror = (e) => { console.error("Error reading file:", e); alert("Failed to read the selected file."); event.target.value = null; };
            reader.readAsText(file);
        };

        // --- Local Storage Persistence ---
        const POMODORO_SETTINGS_KEY = 'pomodoroSettings_v3'; // Incremented key for new setting
        const KANBAN_TASKS_KEY = 'kanbanTasks';

        // --- Board Visual State Updates ---
        const updateSpinnerAnimation = () => {
            if (inprogressSpinner) {
                const hasTasks = inprogressTasksContainer.children.length > 0;
                inprogressSpinner.classList.toggle('fa-spin', hasTasks);
            }
        };
        const updateDoneGlow = () => {
            if (doneColumn) {
                const todoEmpty = todoTasksContainer.children.length === 0;
                const inprogressEmpty = inprogressTasksContainer.children.length === 0;
                const doneHasTasks = doneTasksContainer.children.length > 0;
                doneColumn.classList.toggle('done-glow', todoEmpty && inprogressEmpty && doneHasTasks);
            }
        };
        const updateBoardState = () => {
            updateSpinnerAnimation();
            updateDoneGlow();
        }

        // --- Save/Load Functions ---
        const saveTasks = () => {
            const tasksData = {};
            columns.forEach(column => {
                const columnId = column.id; tasksData[columnId] = [];
                column.querySelectorAll('.kanban-task').forEach(task => {
                    const textSpan = task.querySelector('.task-text');
                    if (textSpan) {
                        tasksData[columnId].push({
                            id: task.id, text: textSpan.textContent, labels: JSON.parse(task.dataset.labels || '[]'),
                            startTime: task.dataset.timerStartTime ? parseInt(task.dataset.timerStartTime, 10) : null,
                            totalTime: parseInt(task.dataset.totalTime || '0', 10)
                        });
                    }
                });
            });
            try { localStorage.setItem(KANBAN_TASKS_KEY, JSON.stringify(tasksData)); }
            catch (error) { console.error("Error saving tasks to localStorage:", error); }
            updateBoardState();
        };
        const loadTasksFromData = (tasksData) => {
             Object.keys(tasksData).forEach(columnId => {
                 const columnElement = document.getElementById(columnId);
                 if (columnElement) {
                     const tasksContainer = columnElement.querySelector('.tasks-container');
                     tasksData[columnId].forEach(taskData => {
                         if(taskData && taskData.id && typeof taskData.text === 'string') {
                             taskData.labels = Array.isArray(taskData.labels) ? taskData.labels : [];
                             const taskElement = createTaskElement(taskData); tasksContainer.appendChild(taskElement);

                             if (columnId === 'inprogress') {
                                 if (taskData.startTime) {
                                     startTaskTimerInterval(taskElement, taskData.startTime);
                                 } else if (taskData.totalTime > 0) {
                                     displayTotalTaskTime(taskElement, taskData.totalTime);
                                 } else {
                                     const timerDiv = taskElement.querySelector('.task-timer');
                                     if(timerDiv) timerDiv.style.display = 'none';
                                 }
                             } else if (columnId === 'done') {
                                 displayTotalTaskTime(taskElement, taskData.totalTime || 0);
                             } else {
                                 const timerDiv = taskElement.querySelector('.task-timer');
                                 if(timerDiv) timerDiv.style.display = 'none';
                             }
                         } else { console.warn("Skipping invalid task data during load/import:", taskData); }
                     });
                 }
             });
             updateBoardState();
             updateZenMode();
        };
        const loadTasks = () => {
             Object.values(activeTaskTimers).forEach(clearInterval); for (const key in activeTaskTimers) { delete activeTaskTimers[key]; }
             let savedTasksJson; try { savedTasksJson = localStorage.getItem(KANBAN_TASKS_KEY); } catch (error) { console.error("Error reading tasks from localStorage:", error); return; }
             if (savedTasksJson) {
                 try { const tasksData = JSON.parse(savedTasksJson); loadTasksFromData(tasksData); }
                 catch (error) { console.error("Error parsing saved tasks JSON:", error); localStorage.removeItem(KANBAN_TASKS_KEY); updateBoardState(); updateZenMode(); }
             } else {
                 updateBoardState();
                 updateZenMode();
             }
        };
        const loadPomodoroSettings = () => {
            try {
                const savedSettings = localStorage.getItem(POMODORO_SETTINGS_KEY);
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    currentWorkMins = parseInt(settings.work, 10) || DEFAULT_WORK_MINS;
                    currentShortBreakMins = parseInt(settings.shortBreak, 10) || DEFAULT_SHORT_BREAK_MINS;
                    currentLongBreakMins = parseInt(settings.longBreak, 10) || DEFAULT_LONG_BREAK_MINS;
                    currentLongBreakInterval = parseInt(settings.longBreakInterval, 10) || DEFAULT_LONG_BREAK_INTERVAL;
                    currentAutoStartBreaks = settings.autoStartBreaks ?? DEFAULT_AUTO_START_BREAKS;
                    currentAutoStartWork = settings.autoStartWork ?? DEFAULT_AUTO_START_WORK;
                    currentEnableSounds = settings.enableSounds ?? DEFAULT_ENABLE_SOUNDS;
                    currentEnableZenMode = settings.enableZenMode ?? DEFAULT_ENABLE_ZEN_MODE; // Load Zen Mode setting

                } else {
                    // Set defaults if nothing is saved
                    currentWorkMins = DEFAULT_WORK_MINS;
                    currentShortBreakMins = DEFAULT_SHORT_BREAK_MINS;
                    currentLongBreakMins = DEFAULT_LONG_BREAK_MINS;
                    currentLongBreakInterval = DEFAULT_LONG_BREAK_INTERVAL;
                    currentAutoStartBreaks = DEFAULT_AUTO_START_BREAKS;
                    currentAutoStartWork = DEFAULT_AUTO_START_WORK;
                    currentEnableSounds = DEFAULT_ENABLE_SOUNDS;
                    currentEnableZenMode = DEFAULT_ENABLE_ZEN_MODE;
                }
            } catch (error) {
                console.error("Error loading Pomodoro settings:", error);
                // Fallback to defaults on error
                currentWorkMins = DEFAULT_WORK_MINS;
                currentShortBreakMins = DEFAULT_SHORT_BREAK_MINS;
                currentLongBreakMins = DEFAULT_LONG_BREAK_MINS;
                currentLongBreakInterval = DEFAULT_LONG_BREAK_INTERVAL;
                currentAutoStartBreaks = DEFAULT_AUTO_START_BREAKS;
                currentAutoStartWork = DEFAULT_AUTO_START_WORK;
                currentEnableSounds = DEFAULT_ENABLE_SOUNDS;
                currentEnableZenMode = DEFAULT_ENABLE_ZEN_MODE;
            }
            resetPomodoroTimerTime(false);
        };
        const savePomodoroSettings = (settings) => {
             try { localStorage.setItem(POMODORO_SETTINGS_KEY, JSON.stringify(settings)); }
             catch (error) { console.error("Error saving Pomodoro settings:", error); alert("Could not save Pomodoro settings."); }
        };
        const handleSavePomodoroSettings = () => {
             const newWorkMins = parseInt(settingWorkMinsInput.value, 10);
             const newShortBreakMins = parseInt(settingShortBreakMinsInput.value, 10);
             const newLongBreakMins = parseInt(settingLongBreakMinsInput.value, 10);
             const newLongBreakInterval = parseInt(settingLongBreakIntervalInput.value, 10);
             const newAutoStartBreaks = settingAutoStartBreaksInput.checked;
             const newAutoStartWork = settingAutoStartWorkInput.checked;
             const newEnableSounds = settingEnableSoundsInput.checked;
             const newEnableZenMode = settingEnableZenModeInput.checked; // Read Zen Mode toggle

             if (isNaN(newWorkMins) || newWorkMins < 1 ||
                 isNaN(newShortBreakMins) || newShortBreakMins < 1 ||
                 isNaN(newLongBreakMins) || newLongBreakMins < 1 ||
                 isNaN(newLongBreakInterval) || newLongBreakInterval < 1) {
                 alert("Please enter valid positive numbers for all durations and the cycle interval."); return;
             }

             currentWorkMins = newWorkMins;
             currentShortBreakMins = newShortBreakMins;
             currentLongBreakMins = newLongBreakMins;
             currentLongBreakInterval = newLongBreakInterval;
             currentAutoStartBreaks = newAutoStartBreaks;
             currentAutoStartWork = newAutoStartWork;
             currentEnableSounds = newEnableSounds;
             currentEnableZenMode = newEnableZenMode; // Update Zen Mode setting

             savePomodoroSettings({
                 work: currentWorkMins,
                 shortBreak: currentShortBreakMins,
                 longBreak: currentLongBreakMins,
                 longBreakInterval: currentLongBreakInterval,
                 autoStartBreaks: currentAutoStartBreaks,
                 autoStartWork: currentAutoStartWork,
                 enableSounds: currentEnableSounds,
                 enableZenMode: currentEnableZenMode // Save Zen Mode setting
             });

             handlePomodoroReset(); // Resets timer and updates Zen Mode based on new setting
             pomodoroSettingsDiv.classList.remove('active');
             alert("Pomodoro settings saved!");
             updateZenMode(); // Explicitly update zen mode after saving settings
        };

        // --- Event Listener Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            loadPomodoroSettings();
            loadTasks();
            handlePomodoroReset();

            ['click', 'keypress', 'dragstart'].forEach(evt => {
                document.body.addEventListener(evt, initAudio, { once: true });
            });

            document.addEventListener('keydown', (e) => { if (e.altKey && e.key.toLowerCase() === 'n') { e.preventDefault(); newTaskInput.focus(); } });
        });
        addTaskBtn.addEventListener('click', addTask);
        newTaskInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTask(); });
        newTaskLabels.addEventListener('keypress', (e) => { if (e.key === 'Enter') addTask(); });
        clearDoneBtn.addEventListener('click', handleClearDone);
        tasksContainers.forEach(container => {
            container.addEventListener('dragover', handleDragOver); container.addEventListener('dragenter', handleDragEnter);
            container.addEventListener('dragleave', handleDragLeave); container.addEventListener('drop', handleDrop);
        });
        confirmBtn.addEventListener('click', () => { if (typeof confirmCallback === 'function') { try { confirmCallback(); } catch (error) { console.error("Error executing confirmation callback:", error); } } hideConfirmationModal(); });
        cancelBtn.addEventListener('click', hideConfirmationModal);
        confirmationModal.addEventListener('click', (e) => { if (e.target === confirmationModal) hideConfirmationModal(); });
        pomodoroStartBtn.addEventListener('click', startPomodoro);
        pomodoroPauseBtn.addEventListener('click', pausePomodoro);
        pomodoroResetBtn.addEventListener('click', handlePomodoroReset);
        exportDataBtn.addEventListener('click', exportData);
        importDataInput.addEventListener('change', handleImportData);
        pomodoroSettingsToggleBtn.addEventListener('click', () => {
            const isActive = pomodoroSettingsDiv.classList.toggle('active');
            if (isActive) {
                settingWorkMinsInput.value = currentWorkMins;
                settingShortBreakMinsInput.value = currentShortBreakMins;
                settingLongBreakMinsInput.value = currentLongBreakMins;
                settingLongBreakIntervalInput.value = currentLongBreakInterval;
                settingAutoStartBreaksInput.checked = currentAutoStartBreaks;
                settingAutoStartWorkInput.checked = currentAutoStartWork;
                settingEnableSoundsInput.checked = currentEnableSounds;
                settingEnableZenModeInput.checked = currentEnableZenMode; // Populate Zen Mode toggle
            }
        });
        pomodoroSaveSettingsBtn.addEventListener('click', handleSavePomodoroSettings);

    </script>

</body>
</html>
